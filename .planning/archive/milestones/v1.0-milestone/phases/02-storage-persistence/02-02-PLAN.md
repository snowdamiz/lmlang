---
phase: 02-storage-persistence
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - crates/lmlang-storage/Cargo.toml
  - crates/lmlang-storage/src/lib.rs
  - crates/lmlang-storage/src/error.rs
  - crates/lmlang-storage/src/schema.rs
  - crates/lmlang-storage/src/sqlite.rs
  - crates/lmlang-storage/src/migrations/001_initial_schema.sql
autonomous: true
requirements:
  - STORE-01

must_haves:
  truths:
    - "A ProgramGraph saved to SQLite can be loaded back with all nodes, edges, types, functions, modules, and semantic data intact across process restarts"
    - "SQLite uses WAL mode with atomic transactions for every logical write operation"
    - "Schema migrations are applied automatically via rusqlite_migration on database open"
    - "Multi-program database: single SQLite file holds multiple programs with a programs table"
  artifacts:
    - path: "crates/lmlang-storage/src/sqlite.rs"
      provides: "SqliteStore implementing GraphStore"
      min_lines: 150
    - path: "crates/lmlang-storage/src/schema.rs"
      provides: "SQL schema constants and migration setup"
      min_lines: 20
    - path: "crates/lmlang-storage/src/migrations/001_initial_schema.sql"
      provides: "Initial SQL schema with all tables and indices"
      min_lines: 50
  key_links:
    - from: "crates/lmlang-storage/src/sqlite.rs"
      to: "crates/lmlang-storage/src/traits.rs"
      via: "impl GraphStore for SqliteStore"
      pattern: "impl GraphStore for SqliteStore"
    - from: "crates/lmlang-storage/src/sqlite.rs"
      to: "crates/lmlang-storage/src/convert.rs"
      via: "uses decompose/recompose for save_program/load_program"
      pattern: "decompose|recompose"
    - from: "crates/lmlang-storage/src/schema.rs"
      to: "crates/lmlang-storage/src/migrations/001_initial_schema.sql"
      via: "include_str! loads migration SQL"
      pattern: "include_str!"
---

<objective>
Implement SQLite persistence backend with atomic writes, schema migrations, and full ProgramGraph save/load roundtrip.

Purpose: Delivers STORE-01 -- programs persist in SQLite across process restarts. The normalized relational schema (per user decision) stores nodes, edges, types, functions, modules, and semantic data in separate tables with JSON TEXT columns for complex enum types. Every write operation uses a transaction for atomicity.

Output: Working SqliteStore that passes save/load roundtrip tests with the same fidelity as InMemoryStore.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-storage-persistence/02-RESEARCH.md
@.planning/phases/02-storage-persistence/02-CONTEXT.md
@.planning/phases/02-storage-persistence/02-01-SUMMARY.md
@crates/lmlang-storage/src/traits.rs
@crates/lmlang-storage/src/error.rs
@crates/lmlang-storage/src/convert.rs
@crates/lmlang-storage/src/memory.rs
@crates/lmlang-core/src/graph.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQL schema, migration setup, and SqliteStore implementation</name>
  <files>
    crates/lmlang-storage/Cargo.toml
    crates/lmlang-storage/src/lib.rs
    crates/lmlang-storage/src/error.rs
    crates/lmlang-storage/src/schema.rs
    crates/lmlang-storage/src/sqlite.rs
    crates/lmlang-storage/src/migrations/001_initial_schema.sql
  </files>
  <action>
1. Update `crates/lmlang-storage/Cargo.toml`:
   - Add dependencies: `rusqlite = { version = "0.38", features = ["bundled"] }`, `rusqlite_migration = "2.4"`

2. Create `crates/lmlang-storage/src/migrations/001_initial_schema.sql`:
   - Per user decision: normalized relational schema with separate tables
   - Tables (see 02-RESEARCH.md Example 1 for full schema):
     - `programs` (id INTEGER PRIMARY KEY, name TEXT UNIQUE, created_at TEXT, updated_at TEXT)
     - `types` (program_id, type_id, type_json TEXT, name TEXT nullable) with composite PK
     - `modules` (program_id, module_id, name, parent_id nullable, visibility) with composite PK and self-referential FK
     - `functions` (program_id, function_id, name, module_id, visibility, params_json, return_type_id, entry_node_id nullable, is_closure, parent_function nullable, captures_json) with composite PK
     - `compute_nodes` (program_id, node_id, owner_fn_id, op_json TEXT) with composite PK
     - `flow_edges` (program_id, edge_id, source_id, target_id, edge_json TEXT) with composite PK
     - `semantic_nodes` (program_id, node_idx, node_json TEXT) with composite PK
     - `semantic_edges` (program_id, edge_idx, source_idx, target_idx, edge_type TEXT) with composite PK
   - Indices: on compute_nodes(owner_fn_id), flow_edges(source_id), flow_edges(target_id), functions(module_id), modules(parent_id)
   - Enable `PRAGMA foreign_keys = ON` at connection level (not in migration)

3. Create `crates/lmlang-storage/src/schema.rs`:
   - Import `rusqlite_migration::{Migrations, M}`
   - Define `MIGRATIONS` const using `Migrations::from_slice(&[M::up(include_str!("migrations/001_initial_schema.sql"))])`
   - `pub fn open_database(path: &str) -> Result<rusqlite::Connection, StorageError>`:
     - Open connection with `Connection::open(path)`
     - Set pragmas: `journal_mode=WAL`, `synchronous=NORMAL`, `foreign_keys=ON`
     - Apply migrations: `MIGRATIONS.to_latest(&mut conn)`
     - Return connection
   - `pub fn open_in_memory() -> Result<rusqlite::Connection, StorageError>`:
     - Like `open_database` but with `Connection::open_in_memory()`
     - Same pragmas and migrations

4. Update `crates/lmlang-storage/src/error.rs`:
   - Add `Sqlite(#[from] rusqlite::Error)` variant
   - Add `Migration(String)` variant (wrap rusqlite_migration error as string since it may not implement std::error::Error cleanly -- check during implementation, use #[from] if it does)

5. Create `crates/lmlang-storage/src/sqlite.rs`:
   - `SqliteStore` struct with `conn: rusqlite::Connection`
   - Constructor: `pub fn new(path: &str) -> Result<Self, StorageError>` using `schema::open_database`
   - Constructor: `pub fn in_memory() -> Result<Self, StorageError>` using `schema::open_in_memory`
   - Implement `GraphStore for SqliteStore`:
     - `create_program`: INSERT into programs, return ProgramId from last_insert_rowid
     - `save_program`: decompose ProgramGraph, then in a single transaction: DELETE existing rows for this program (if any), INSERT all types, modules, functions, compute_nodes, flow_edges, semantic_nodes, semantic_edges. Use prepared statements via `prepare_cached` for batch inserts.
     - `load_program`: in one transaction, SELECT all rows for the program from each table, build DecomposedProgram, call recompose. Deserialize JSON TEXT columns back to Rust types using serde_json::from_str.
     - `delete_program`: DELETE FROM programs WHERE id = ?; CASCADE handles child tables
     - `list_programs`: SELECT id, name FROM programs
     - `save_function`: in a single transaction, DELETE existing compute_nodes and flow_edges owned by this function, DELETE the function row, then re-INSERT the function definition and its nodes/edges from the ProgramGraph. Uses decompose internally to extract only the function's data.
     - Node CRUD: each method wraps a single SQL statement in a transaction. Use `prepare_cached` for the statement.
       - `insert_node`: INSERT into compute_nodes with serde_json::to_string for op_json
       - `get_node`: SELECT, deserialize op_json
       - `update_node`: UPDATE compute_nodes SET op_json=?, owner_fn_id=?
       - `delete_node`: DELETE FROM compute_nodes
     - Edge CRUD: similar pattern with flow_edges table
     - Type CRUD: INSERT/SELECT on types table with type_json
     - Function CRUD: INSERT/SELECT/UPDATE on functions table with params_json and captures_json
     - Module CRUD: INSERT/SELECT on modules table
     - Semantic CRUD: INSERT/SELECT on semantic_nodes (node_json) and semantic_edges (edge_type)
     - Query methods:
       - `find_nodes_by_owner`: SELECT FROM compute_nodes WHERE owner_fn_id = ?
       - `find_edges_from`: SELECT FROM flow_edges WHERE source_id = ?
       - `find_edges_to`: SELECT FROM flow_edges WHERE target_id = ?
       - `find_functions_in_module`: SELECT FROM functions WHERE module_id = ?
       - `find_nodes_by_type`: SELECT FROM compute_nodes WHERE program_id = ? then filter deserialized nodes by type_id (type is embedded in op_json, so filter in Rust after deserialize)
       - `list_functions`: SELECT FROM functions WHERE program_id = ?, deserialize all fields, return Vec<(FunctionId, FunctionDef)>
   - Auto-persist pattern: each CRUD method writes to SQLite immediately in its own transaction (per user decision). These individual CRUD methods (insert_node, update_node, etc.) ARE the incremental save mechanism per the research conclusion (Open Question 3). Each call writes exactly one changed row. `save_program` is for initial bulk save of a newly created program or full overwrite -- not for incremental updates. No dirty-tracking needed.

6. Update `crates/lmlang-storage/src/lib.rs`:
   - Add `pub mod schema;` and `pub mod sqlite;`
   - Re-export `SqliteStore`

IMPORTANT: JSON TEXT columns use `serde_json::to_string` for serialization and `serde_json::from_str` for deserialization. All Phase 1 types already derive Serialize/Deserialize with tested roundtrips, so this is safe.

IMPORTANT: Every method that writes data must use `self.conn.transaction()` for atomicity (per user decision and Pitfall 4 from research).
  </action>
  <verify>
    `cargo check -p lmlang-storage` compiles. `cargo test -p lmlang-storage` passes (existing tests still pass).
  </verify>
  <done>
    SqliteStore implements GraphStore with normalized relational schema, WAL mode, transaction-wrapped writes, and schema migrations via rusqlite_migration.
  </done>
</task>

<task type="auto">
  <name>Task 2: SQLite save/load roundtrip integration tests</name>
  <files>
    crates/lmlang-storage/src/sqlite.rs
  </files>
  <action>
Add integration tests in `crates/lmlang-storage/src/sqlite.rs` (in a `#[cfg(test)] mod tests` block):

1. `test_create_and_list_programs`:
   - Create SqliteStore::in_memory()
   - Create two programs with different names
   - list_programs returns both with correct names
   - Create with duplicate name returns error

2. `test_save_load_empty_program`:
   - Create a ProgramGraph::new("main") (just root module, no functions/nodes)
   - save_program, then load_program
   - Verify: semantic_node_count matches, module tree root exists

3. `test_save_load_full_program_roundtrip`:
   - Build the EXACT same multi-function closure program from the Phase 1 integration test (add function, make_adder function, adder closure with captures, compute nodes, data edges, entry nodes)
   - save_program to SqliteStore::in_memory()
   - load_program back
   - Assert ALL of these match between original and loaded:
     - node_count()
     - edge_count()
     - function_count()
     - semantic_node_count()
     - semantic_edge_count()
     - get_function(add_fn_id) name, params count, return_type, entry_node
     - get_function(adder_fn_id) is_closure, captures count, parent_function
     - get_function(make_adder_id) name, params count
     - function_nodes(add_fn_id).len()
   - This is the critical test proving STORE-01 (persistence with data integrity)

4. `test_delete_program`:
   - Create, save, delete
   - load_program returns ProgramNotFound error

5. `test_crud_individual_node`:
   - Create program, save initial graph
   - insert_node with a new compute node
   - get_node returns the same op and owner
   - update_node with different op
   - get_node returns updated op
   - delete_node
   - get_node returns NodeNotFound

6. `test_crud_individual_edge`:
   - Create program with nodes
   - insert_edge between two nodes
   - get_edge returns correct source, target, and edge data
   - delete_edge
   - get_edge returns EdgeNotFound

7. `test_query_nodes_by_owner`:
   - Create program with two functions, add nodes to each
   - find_nodes_by_owner for function 1 returns only function 1's nodes
   - find_nodes_by_owner for function 2 returns only function 2's nodes

8. `test_save_overwrites_previous`:
   - Save program, modify graph (add a node), save again
   - Load and verify the modification is present
   - This tests the "DELETE then re-INSERT" pattern in save_program
  </action>
  <verify>
    `cargo test -p lmlang-storage` passes all tests including all SQLite roundtrip tests. The full program roundtrip test (test #3) proves STORE-01 end-to-end.
  </verify>
  <done>
    SQLite backend passes all roundtrip tests. A multi-function program with closures saved to SQLite loads back with all nodes, edges, types, functions, modules, and semantic data intact. STORE-01 is satisfied.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --workspace` compiles without errors
2. `cargo test -p lmlang-storage` passes all tests
3. The full program roundtrip test proves a graph program saved to SQLite survives load with all data intact
4. Both SqliteStore::in_memory() and SqliteStore::new(path) use the same code paths (WAL, migrations, transactions)
5. Individual CRUD operations demonstrate auto-persist behavior (each write is immediately durable)
</verification>

<success_criteria>
- SqliteStore implements GraphStore completely (all trait methods)
- Full program with closures survives SQLite save/load roundtrip
- Every write uses a transaction for atomicity
- Schema migrations applied automatically on database open
- WAL mode enabled for performance
- Multi-program support works (create, list, delete programs)
</success_criteria>

<output>
After completion, create `.planning/phases/02-storage-persistence/02-02-SUMMARY.md`
</output>

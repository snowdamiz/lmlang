---
phase: 01-core-graph-data-model
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - crates/lmlang-core/src/ops.rs
  - crates/lmlang-core/src/edge.rs
  - crates/lmlang-core/src/node.rs
  - crates/lmlang-core/src/lib.rs
autonomous: true
requirements:
  - GRAPH-01
  - GRAPH-02
  - GRAPH-03
  - GRAPH-06

must_haves:
  truths:
    - "ComputeOp enum contains ~20-25 Tier 1 ops covering arithmetic, comparison, logic, shifts, control flow (high + low level), memory, functions, I/O (console + file), and closures"
    - "StructuredOp enum contains ~8-10 Tier 2 ops for aggregate access, type casts, and enum operations"
    - "Data flow edges carry source_port, target_port, and value_type (TypeId)"
    - "Control flow edges carry optional branch_index for conditional branching"
    - "ComputeNode wraps an op with function ownership metadata"
    - "Every op has a documented LLVM IR lowering path (validated by the mapping table in comments)"
  artifacts:
    - path: "crates/lmlang-core/src/ops.rs"
      provides: "ComputeOp, StructuredOp, ArithOp, CmpOp, LogicOp, ShiftOp, UnaryArithOp"
      contains: "enum ComputeOp"
    - path: "crates/lmlang-core/src/edge.rs"
      provides: "FlowEdge (Data + Control), SemanticEdge"
      contains: "enum FlowEdge"
    - path: "crates/lmlang-core/src/node.rs"
      provides: "ComputeNode, ComputeNodeOp, SemanticNode"
      contains: "struct ComputeNode"
  key_links:
    - from: "crates/lmlang-core/src/ops.rs"
      to: "crates/lmlang-core/src/type_id.rs"
      via: "TypeId used in Cast, StructCreate, EnumCreate ops"
      pattern: "TypeId"
    - from: "crates/lmlang-core/src/ops.rs"
      to: "crates/lmlang-core/src/id.rs"
      via: "FunctionId used in Call and MakeClosure ops"
      pattern: "FunctionId"
    - from: "crates/lmlang-core/src/edge.rs"
      to: "crates/lmlang-core/src/type_id.rs"
      via: "TypeId on data flow edges"
      pattern: "value_type.*TypeId"
    - from: "crates/lmlang-core/src/node.rs"
      to: "crates/lmlang-core/src/ops.rs"
      via: "ComputeNodeOp wraps ComputeOp and StructuredOp"
      pattern: "ComputeOp|StructuredOp"
---

<objective>
Implement the complete op node vocabulary (Tier 1 + Tier 2), edge types (data flow + control flow), and node wrappers for the computational graph.

Purpose: These are the building blocks of the executable computational graph. Ops define what a program can do. Edges define how data and control flow between operations. Nodes wrap ops with ownership metadata. Without these, the graph container (Plan 04) has nothing to store.

Output: Complete op enums with ~30 total operations, edge types for SSA-style data flow and control flow, and node wrappers. All compile and test.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-graph-data-model/01-CONTEXT.md
@.planning/phases/01-core-graph-data-model/01-RESEARCH.md
@.planning/phases/01-core-graph-data-model/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement op node enums (Tier 1 + Tier 2)</name>
  <files>crates/lmlang-core/src/ops.rs</files>
  <action>
Implement the op node enums following the RESEARCH.md code examples exactly, with these specifics:

**Sub-enums for grouped ops:**
- `ArithOp`: `Add, Sub, Mul, Div, Rem` (5 variants). Division semantics (signed vs unsigned) determined by type context during lowering, per LLVM approach.
- `UnaryArithOp`: `Neg, Abs` (2 variants).
- `CmpOp`: `Eq, Ne, Lt, Le, Gt, Ge` (6 variants). Signed/unsigned/float comparison selected during lowering based on input type.
- `LogicOp`: `And, Or, Xor` (3 variants).
- `ShiftOp`: `Shl, ShrLogical, ShrArith` (3 variants).

**ComputeOp enum (Tier 1, ~24 grouped ops):**
Follow the exact layout from RESEARCH.md Pattern 2 example:
- Constants: `Const { value: ConstValue }`
- Arithmetic: `BinaryArith { op: ArithOp }`, `UnaryArith { op: UnaryArithOp }`
- Comparison: `Compare { op: CmpOp }`
- Logic: `BinaryLogic { op: LogicOp }`, `Not`
- Bitwise: `Shift { op: ShiftOp }`
- Control flow (both high and low level per discretion recommendation): `IfElse`, `Loop`, `Match`, `Branch`, `Jump`, `Phi`
- Memory: `Alloc`, `Load`, `Store`, `GetElementPtr`
- Functions: `Call { target: FunctionId }`, `IndirectCall`, `Return`, `Parameter { index: u32 }`
- Console I/O: `Print`, `ReadLine`
- File I/O: `FileOpen`, `FileRead`, `FileWrite`, `FileClose`
- Closures: `MakeClosure { function: FunctionId }`, `CaptureAccess { index: u32 }`

All derive `Debug, Clone, Serialize, Deserialize`. Sub-enums also derive `Copy, PartialEq, Eq`.

**StructuredOp enum (Tier 2, ~10 ops):**
Follow RESEARCH.md exactly:
- `StructCreate { type_id: TypeId }`, `StructGet { field_index: u32 }`, `StructSet { field_index: u32 }`
- `ArrayCreate { length: u32 }`, `ArrayGet`, `ArraySet`
- `Cast { target_type: TypeId }`
- `EnumCreate { type_id: TypeId, variant_index: u32 }`, `EnumDiscriminant`, `EnumPayload { variant_index: u32 }`

All derive `Debug, Clone, Serialize, Deserialize`.

**Important design notes as doc comments:**
- On `ComputeOp`: Document that types are INFERRED from input edges, not stored on the op (per discretion recommendation). Exception: ops with `TypeId` fields (Cast, StructCreate, EnumCreate) carry the minimum necessary type info that cannot be inferred.
- On each control flow op: Document the LLVM lowering path in a brief comment (e.g., `/// Lowers to: br + then_bb + else_bb + merge_bb + phi` on IfElse).
- On `ArithOp::Div` and `CmpOp`: Document that signed/unsigned selection happens at LLVM lowering time based on input type.

**Helper methods:**
- `ComputeOp::is_control_flow(&self) -> bool` -- returns true for IfElse, Loop, Match, Branch, Jump, Phi
- `ComputeOp::is_io(&self) -> bool` -- returns true for Print, ReadLine, FileOpen/Read/Write/Close
- `ComputeOp::is_terminator(&self) -> bool` -- returns true for Return, Branch, Jump (ops that end a basic block)

**Tier classification helpers:**
- `ComputeNodeOp::tier(&self) -> u8` -- returns 1 for ComputeOp, 2 for StructuredOp

Write unit tests:
- Test that `is_control_flow` returns true for all 6 control flow ops and false for others.
- Test that `is_terminator` returns true for Return, Branch, Jump only.
- Test serde round-trip for a representative sample of ops (Const, BinaryArith, Call, StructCreate, Cast).
  </action>
  <verify>`cargo test` passes. Count enum variants: ComputeOp should have ~24 variants, StructuredOp should have 10 variants. Verify with `grep -c "^\s*//" ops.rs` is not useful -- instead check that all ops from the LLVM mapping table in RESEARCH.md are present.</verify>
  <done>Op node enums contain ~24 Tier 1 and 10 Tier 2 operations. Every op from the RESEARCH.md LLVM mapping table is present. Types are inferred from edges (no TypeId on arithmetic/logic/comparison ops). Helper methods classify ops correctly. Serde round-trips work.</done>
</task>

<task type="auto">
  <name>Task 2: Implement edge types and node wrappers</name>
  <files>
    crates/lmlang-core/src/edge.rs
    crates/lmlang-core/src/node.rs
    crates/lmlang-core/src/lib.rs
  </files>
  <action>
**edge.rs** -- Edge types for both graph layers:

`FlowEdge` enum (computational graph edges):
```rust
pub enum FlowEdge {
    Data {
        source_port: u16,
        target_port: u16,
        value_type: TypeId,
    },
    Control {
        branch_index: Option<u16>,
    },
}
```
- Doc comment on `Data`: "SSA-style data dependency. Source node produces a value consumed by target node. Each node produces at most one value (port 0). Multi-output nodes (rare) use higher ports."
- Doc comment on `Control`: "Control dependency. Target executes after source. branch_index is Some(0) for then-branch, Some(1) for else-branch, None for unconditional/sequential ordering."
- Doc comment on `FlowEdge`: "Data flow forms a DAG. Control flow may contain cycles (loops). These are intentionally separate from each other -- LLVM IR distinguishes SSA values from basic block terminators."
- Derive `Debug, Clone, Serialize, Deserialize`.
- Helper methods:
  - `FlowEdge::is_data(&self) -> bool`
  - `FlowEdge::is_control(&self) -> bool`
  - `FlowEdge::value_type(&self) -> Option<TypeId>` -- returns Some for Data, None for Control

`SemanticEdge` enum (semantic graph edges):
```rust
pub enum SemanticEdge {
    Contains,   // Module contains child (module, function, type)
    Calls,      // Function calls another function
    UsesType,   // Function/type references a type
}
```
- Derive `Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize`.

**node.rs** -- Node wrappers for both graph layers:

`ComputeNode` struct:
```rust
pub struct ComputeNode {
    pub op: ComputeNodeOp,
    pub owner: FunctionId,
}
```
- `ComputeNodeOp` enum: `Core(ComputeOp)`, `Structured(StructuredOp)`.
- Both derive `Debug, Clone, Serialize, Deserialize`.
- Convenience constructors:
  - `ComputeNode::new(op: ComputeNodeOp, owner: FunctionId) -> Self`
  - `ComputeNode::core(op: ComputeOp, owner: FunctionId) -> Self` -- wraps in ComputeNodeOp::Core
  - `ComputeNode::structured(op: StructuredOp, owner: FunctionId) -> Self` -- wraps in ComputeNodeOp::Structured
- Delegate `is_control_flow()`, `is_terminator()`, `is_io()` to inner op.
- `tier(&self) -> u8` -- delegates to ComputeNodeOp::tier.

`SemanticNode` enum:
```rust
pub enum SemanticNode {
    Module(ModuleDef),
    Function(FunctionSummary),
    TypeDef(TypeDefNode),
}
```
Note: Use `FunctionSummary` (not the full `FunctionDef` -- that goes in a separate lookup table) containing just `name: String, function_id: FunctionId, module: ModuleId, visibility: Visibility, signature: FunctionSignature`. `FunctionSignature` is a struct with `params: Vec<(String, TypeId)>, return_type: TypeId`.

`TypeDefNode` struct: `name: String, type_id: TypeId, module: ModuleId, visibility: Visibility`.

All derive `Debug, Clone, Serialize, Deserialize`.

**lib.rs** -- Add module declarations and re-exports for the new modules:
```rust
pub mod ops;
pub mod edge;
pub mod node;
```
Re-export key types: `ComputeOp, StructuredOp, ComputeNodeOp, ComputeNode, FlowEdge, SemanticEdge, SemanticNode`.

Note: `SemanticNode` references `ModuleDef` and `FunctionSummary`. Since `function.rs` and `module.rs` are created in Plan 03, define `FunctionSummary`, `FunctionSignature`, `TypeDefNode`, and a TEMPORARY forward stub for `ModuleDef` directly in `node.rs` for now. Add a `// TODO(plan-03): Move ModuleDef to module.rs when it exists` comment. Plan 03 will refactor this -- the stub just needs `name: String, parent: Option<ModuleId>, visibility: Visibility` so the code compiles.

Write unit tests:
- `edge.rs`: Test FlowEdge::is_data/is_control. Test value_type returns correct Option. Test serde round-trip for both Data and Control edges.
- `node.rs`: Test ComputeNode constructors. Test tier() returns 1 for Core, 2 for Structured. Test delegation of is_control_flow through ComputeNode.
  </action>
  <verify>`cargo test` passes. `cargo build` compiles with no errors. Verify FlowEdge has exactly 2 variants (Data, Control). Verify SemanticEdge has exactly 3 variants.</verify>
  <done>FlowEdge supports typed SSA data flow and control flow with branch indices. SemanticEdge supports structural relationships. ComputeNode wraps ops with ownership. SemanticNode covers module/function/type definition nodes. All types serialize/deserialize correctly.</done>
</task>

</tasks>

<verification>
- `cargo build` and `cargo test` pass
- ComputeOp has ~24 variants covering all Tier 1 operations from the LLVM mapping table
- StructuredOp has 10 variants covering all Tier 2 operations
- FlowEdge::Data carries source_port, target_port, value_type (TypeId)
- FlowEdge::Control carries optional branch_index
- ComputeNode has owner: FunctionId for flat-graph function boundaries
- No TypeId on arithmetic/logic/comparison ops (type-inferred per discretion)
- I/O ops present: Print, ReadLine, FileOpen, FileRead, FileWrite, FileClose (per user decision)
- Both high-level (IfElse, Loop, Match) and low-level (Branch, Jump, Phi) control flow ops present (per discretion)
</verification>

<success_criteria>
- All ~34 ops (24 Tier 1 + 10 Tier 2) are defined with correct grouping parameters
- Edge types separate data flow from control flow per SSA conventions
- Node wrappers include function ownership for flat-graph boundary representation
- Every op has a clear LLVM IR lowering path documented in comments
- All types are serde-serializable
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-graph-data-model/01-02-SUMMARY.md`
</output>

---
phase: 05-llvm-compilation-pipeline
plan: 04
type: execute
wave: 4
depends_on: [05-03]
files_modified:
  - crates/lmlang-codegen/tests/integration_tests.rs
autonomous: true
requirements: [EXEC-02, EXEC-03, EXEC-04]

must_haves:
  truths:
    - "A simple arithmetic program compiles to a binary that produces the same output as the interpreter"
    - "A program with conditionals (IfElse) compiles and produces correct branching behavior"
    - "A program with a loop compiles and iterates the correct number of times"
    - "A multi-function program with Call ops compiles and call chains work correctly"
    - "Division by zero in a compiled binary aborts with exit code 1 and error message containing the node ID"
    - "Integer overflow in a compiled binary aborts with exit code 2"
    - "Compilation with O0 and O2 both produce correct results"
    - "compile_to_ir produces valid LLVM IR string for inspection"
  artifacts:
    - path: "crates/lmlang-codegen/tests/integration_tests.rs"
      provides: "End-to-end tests proving compiled output matches interpreter output"
      min_lines: 200
  key_links:
    - from: "crates/lmlang-codegen/tests/integration_tests.rs"
      to: "lmlang_codegen::compile"
      via: "Calls compile() to produce binaries, runs them, compares output"
      pattern: "lmlang_codegen::compile"
    - from: "crates/lmlang-codegen/tests/integration_tests.rs"
      to: "lmlang_check::interpreter"
      via: "Runs interpreter on same graph to get expected output"
      pattern: "Interpreter"
---

<objective>
Write end-to-end integration tests that build graph programs, compile them to native binaries, run the binaries, and verify the output matches the interpreter -- proving correctness of the entire LLVM compilation pipeline.

Purpose: Proves all four success criteria for Phase 5 are met: op-to-IR mapping correctness, native binary production, function-scoped Context isolation, and output equivalence with interpreter.
Output: Comprehensive integration test suite covering arithmetic, control flow, functions, runtime errors, and optimization levels.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llvm-compilation-pipeline/05-RESEARCH.md
@.planning/phases/05-llvm-compilation-pipeline/05-CONTEXT.md
@.planning/phases/05-llvm-compilation-pipeline/05-01-SUMMARY.md
@.planning/phases/05-llvm-compilation-pipeline/05-02-SUMMARY.md
@.planning/phases/05-llvm-compilation-pipeline/05-03-SUMMARY.md
@crates/lmlang-codegen/src/lib.rs
@crates/lmlang-codegen/src/compiler.rs
@crates/lmlang-core/src/graph.rs
@crates/lmlang-check/src/interpreter/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core integration tests: arithmetic, control flow, functions</name>
  <files>
    crates/lmlang-codegen/tests/integration_tests.rs
  </files>
  <action>
Create integration tests that build graph programs using the ProgramGraph builder API, compile them via `lmlang_codegen::compile()`, execute the resulting binary, and verify output.

**Test helper functions:**

```rust
/// Build a graph, compile it, run the binary, return (stdout, stderr, exit_code)
fn compile_and_run(graph: &ProgramGraph, opt_level: OptLevel) -> (String, String, i32) {
    let temp_dir = tempfile::tempdir().unwrap();
    let options = CompileOptions {
        output_dir: temp_dir.path().to_path_buf(),
        opt_level,
        target_triple: None,  // host
        debug_symbols: false,
        entry_function: None,
    };
    let result = lmlang_codegen::compile(graph, &options).unwrap();
    let output = std::process::Command::new(&result.binary_path)
        .output()
        .unwrap();
    (
        String::from_utf8_lossy(&output.stdout).to_string(),
        String::from_utf8_lossy(&output.stderr).to_string(),
        output.status.code().unwrap_or(-1),
    )
}

/// Run interpreter on graph and return captured Print output
fn interpret_and_capture(graph: &ProgramGraph, func_id: FunctionId, inputs: &[Value]) -> Vec<Value> {
    // Use interpreter from lmlang-check
}
```

**Test 1: Simple arithmetic (2 + 3 = 5)**
- Build graph: function "main" with Const(I32(2)), Const(I32(3)), BinaryArith(Add), Print, Return
- Wire edges: const1 -> add port 0, const2 -> add port 1, add -> print port 0, unit -> return
- Compile and run
- Assert stdout contains "5" and exit code is 0
- Also run interpreter on same graph, verify both produce "5"

**Test 2: Nested arithmetic ((10 - 3) * 4 = 28)**
- Build graph with Sub and Mul nodes
- Compile, run, assert stdout "28", exit 0
- Verify matches interpreter

**Test 3: Comparison and boolean output**
- Build: Const(I32(5)), Const(I32(3)), Compare(Gt), Print
- Compile, run, assert stdout contains "true" (or "1"), exit 0

**Test 4: IfElse control flow**
- Build: Const(Bool(true)), IfElse, two branches each with Const+Print, merge
- True branch prints "yes", false branch prints "no"
- Compile, run, assert stdout contains "yes"
- Then build same with Const(Bool(false)), assert stdout contains "no"

**Test 5: Loop (sum 1 to 5 = 15)**
- Build: Loop with Alloc for accumulator and counter, Store/Load, BinaryArith(Add), Compare(Lt), Loop condition
- Follow the memory-based loop pattern from Phase 3
- Compile, run, assert stdout contains "15"
- Verify matches interpreter

**Test 6: Multi-function with Call**
- Build: function "add_one" takes I32, returns I32 (param + const 1)
- Build: function "main" calls add_one(10), prints result
- Compile, run, assert stdout contains "11"

**Test 7: Multiple operations chain**
- Build: function computing `(a + b) * (a - b)` where a=7, b=3 -> (10) * (4) = 40
- Compile, run, assert stdout "40"
  </action>
  <verify>
`cargo test -p lmlang-codegen --test integration_tests` -- all tests pass. Each test compiles a graph, runs the binary, and verifies correct output.
  </verify>
  <done>
Core arithmetic, comparison, control flow (IfElse, Loop), and multi-function Call tests all pass. Compiled binaries produce output matching interpreter for all test cases. Exit code 0 on success.
  </done>
</task>

<task type="auto">
  <name>Task 2: Runtime error tests, optimization levels, and IR inspection</name>
  <files>
    crates/lmlang-codegen/tests/integration_tests.rs
  </files>
  <action>
Add tests for runtime error handling, optimization levels, and LLVM IR output.

**Test 8: Division by zero runtime error**
- Build: Const(I32(10)), Const(I32(0)), BinaryArith(Div), Return
- Compile and run
- Assert exit code is 1 (DivideByZero)
- Assert stderr contains "Runtime error" and contains the node ID of the Div node
- This validates the node-ID-in-error-message user decision

**Test 9: Integer overflow runtime error**
- Build: Const(I32(i32::MAX)), Const(I32(1)), BinaryArith(Add), Return
- Compile and run
- Assert exit code is 2 (IntegerOverflow)
- Assert stderr contains "Runtime error" and "overflow"

**Test 10: Optimization levels produce correct results**
- Build the simple arithmetic graph from Test 1
- Compile and run at O0 -- assert stdout "5"
- Compile and run at O2 -- assert stdout "5"
- Both must produce same correct output (optimization must not change semantics)

**Test 11: compile_to_ir produces valid LLVM IR**
- Build simple graph
- Call `lmlang_codegen::compile_to_ir(graph, options)`
- Assert result contains "define" (function definition)
- Assert result contains "@main" (main wrapper)
- Assert result contains "add" or "call" (some instructions)

**Test 12: Type checker rejects invalid graph before codegen**
- Build a graph with a type mismatch (e.g., BinaryArith with bool and i32 inputs without coercion)
- Call compile() -- assert it returns CodegenError::TypeCheckFailed
- Verify the error contains diagnostic info

**Test 13: CompileResult fields are populated**
- Build simple graph, compile
- Assert result.binary_path exists on disk
- Assert result.binary_size > 0
- Assert result.compilation_time_ms >= 0
- Assert result.target_triple is non-empty (contains "aarch64" or "x86_64" depending on host)

**Test 14: Struct operations (if time permits)**
- Build: StructCreate with two I32 fields, StructGet field 0, Print
- Compile, run, verify correct field value printed

**Test 15: Cast operations**
- Build: Const(I32(42)), Cast to I64, Print
- Compile, run, verify "42" printed correctly

Ensure test cleanup: use tempdir for all output binaries so they're cleaned up after each test.
  </action>
  <verify>
`cargo test -p lmlang-codegen --test integration_tests` -- all tests pass including runtime error tests, optimization level tests, and IR inspection tests.
  </verify>
  <done>
Runtime errors produce correct exit codes with node IDs in messages. O0 and O2 both produce correct results. LLVM IR inspection works. Type checker rejects invalid graphs before codegen. CompileResult fields are populated correctly. All integration tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo test -p lmlang-codegen --test integration_tests` -- all tests pass
- At least 10 integration tests covering arithmetic, control flow, functions, runtime errors, optimization levels
- Compiled binary output matches interpreter output for the same programs
- Runtime errors include node IDs in error messages
- Exit codes follow convention: 0=success, 1=div-by-zero, 2=overflow
- Tests clean up temp directories
</verification>

<success_criteria>
- All integration tests pass: arithmetic, IfElse, Loop, Call, runtime errors, optimization levels
- For every test program, compiled binary output == interpreter output (Phase 5 Success Criterion 4)
- Division by zero produces exit code 1 with node ID in error message
- Integer overflow produces exit code 2
- Both O0 and O2 produce correct output
- Type checker rejection works before codegen
- CompileResult contains valid binary_path, target_triple, binary_size, compilation_time_ms
</success_criteria>

<output>
After completion, create `.planning/phases/05-llvm-compilation-pipeline/05-04-SUMMARY.md`
</output>

---
phase: 04-ai-agent-tool-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/lmlang-check/Cargo.toml
  - crates/lmlang-check/src/interpreter/value.rs
  - crates/lmlang-check/src/interpreter/trace.rs
  - crates/lmlang-check/src/interpreter/error.rs
  - crates/lmlang-check/src/typecheck/diagnostics.rs
  - crates/lmlang-server/Cargo.toml
  - crates/lmlang-server/src/lib.rs
  - crates/lmlang-server/src/error.rs
  - crates/lmlang-server/src/schema/mod.rs
  - crates/lmlang-server/src/schema/mutations.rs
  - crates/lmlang-server/src/schema/queries.rs
  - crates/lmlang-server/src/schema/diagnostics.rs
  - crates/lmlang-server/src/schema/simulate.rs
  - crates/lmlang-server/src/schema/history.rs
  - crates/lmlang-server/src/schema/programs.rs
  - crates/lmlang-server/src/schema/common.rs
  - crates/lmlang-server/src/schema/verify.rs
autonomous: true
requirements:
  - TOOL-05
  - TOOL-06

must_haves:
  truths:
    - "cargo check -p lmlang-server passes with all schema types compiling"
    - "cargo test -p lmlang-check passes (serde derives do not break existing tests)"
    - "Value serializes to valid JSON and deserializes back without data loss"
    - "API error responses return structured JSON with HTTP status codes (400, 404, 409, 422, 500)"
    - "DiagnosticError converts from every TypeError variant with a distinct error code"
  artifacts:
    - path: "crates/lmlang-server/Cargo.toml"
      provides: "Server crate manifest with axum 0.8, tokio, tower-http, serde, uuid, tracing, rusqlite"
    - path: "crates/lmlang-server/src/error.rs"
      provides: "ApiError enum, ApiErrorDetail, IntoResponse impl"
      exports: ["ApiError", "ApiErrorDetail"]
    - path: "crates/lmlang-server/src/schema/mutations.rs"
      provides: "ProposeEditRequest, Mutation, ProposeEditResponse, CreatedEntity"
      exports: ["ProposeEditRequest", "Mutation", "ProposeEditResponse"]
    - path: "crates/lmlang-server/src/schema/queries.rs"
      provides: "NodeView, EdgeView, FunctionView, DetailLevel, query request/response types"
      exports: ["DetailLevel", "NodeView", "EdgeView"]
    - path: "crates/lmlang-server/src/schema/diagnostics.rs"
      provides: "DiagnosticError, DiagnosticWarning, DiagnosticDetails"
      exports: ["DiagnosticError", "DiagnosticWarning"]
    - path: "crates/lmlang-server/src/schema/simulate.rs"
      provides: "SimulateRequest, SimulateResponse with Value and TraceEntry"
      exports: ["SimulateRequest", "SimulateResponse"]
    - path: "crates/lmlang-server/src/schema/history.rs"
      provides: "Undo/redo/checkpoint request/response types"
      exports: ["CreateCheckpointRequest", "HistoryEntry"]
    - path: "crates/lmlang-server/src/schema/verify.rs"
      provides: "VerifyScope enum and VerifyResponse struct"
      exports: ["VerifyScope", "VerifyResponse"]
    - path: "crates/lmlang-server/src/schema/common.rs"
      provides: "ApiResponse<T> generic wrapper"
      exports: ["ApiResponse"]
  key_links:
    - from: "crates/lmlang-server/src/schema/diagnostics.rs"
      to: "crates/lmlang-check/src/typecheck/diagnostics.rs"
      via: "From<TypeError> for DiagnosticError"
      pattern: "impl From<TypeError>"
    - from: "crates/lmlang-server/src/error.rs"
      to: "axum::response::IntoResponse"
      via: "IntoResponse impl returning JSON"
      pattern: "impl IntoResponse for ApiError"
---

<objective>
Create the lmlang-server crate foundation: add Serialize/Deserialize to interpreter/checker types in lmlang-check, create the server crate with all dependencies, define all API schema types (request/response structs), and implement the error response system.

Purpose: Establishes the type foundation that all handlers and service logic will depend on. Ensures internal types can be serialized for API responses.
Output: Compilable lmlang-server crate with schema types, error handling, and serde-ready lmlang-check types.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-agent-tool-api/04-CONTEXT.md
@.planning/phases/04-ai-agent-tool-api/04-RESEARCH.md
@crates/lmlang-check/src/interpreter/value.rs
@crates/lmlang-check/src/interpreter/trace.rs
@crates/lmlang-check/src/interpreter/error.rs
@crates/lmlang-check/src/typecheck/diagnostics.rs
@crates/lmlang-core/src/lib.rs
@crates/lmlang-check/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add serde derives to lmlang-check types and create lmlang-server crate</name>
  <files>
    crates/lmlang-check/Cargo.toml
    crates/lmlang-check/src/interpreter/value.rs
    crates/lmlang-check/src/interpreter/trace.rs
    crates/lmlang-check/src/interpreter/error.rs
    crates/lmlang-check/src/typecheck/diagnostics.rs
    crates/lmlang-server/Cargo.toml
    crates/lmlang-server/src/lib.rs
  </files>
  <action>
    1. Add serde as a dependency to lmlang-check/Cargo.toml: `serde = { version = "1", features = ["derive"] }` and `serde_json = "1"`.

    2. Add `#[derive(Serialize, Deserialize)]` to the following types (add `use serde::{Serialize, Deserialize};` to each file):
       - `Value` enum in interpreter/value.rs
       - `TraceEntry` struct in interpreter/trace.rs
       - `RuntimeError` enum in interpreter/error.rs (also add `#[derive(Clone)]` since thiserror Error types sometimes need it for API serialization)
       - `TypeError` enum in typecheck/diagnostics.rs
       - `FixSuggestion` enum in typecheck/diagnostics.rs (already has Clone, add Serialize/Deserialize)

    3. Create `crates/lmlang-server/` directory structure:
       ```
       crates/lmlang-server/
       ├── Cargo.toml
       └── src/
           └── lib.rs
       ```

    4. Create Cargo.toml for lmlang-server:
       ```toml
       [package]
       name = "lmlang-server"
       version = "0.1.0"
       edition = "2021"

       [dependencies]
       lmlang-core = { path = "../lmlang-core" }
       lmlang-check = { path = "../lmlang-check" }
       lmlang-storage = { path = "../lmlang-storage" }
       axum = "0.8"
       tokio = { version = "1", features = ["full"] }
       tower = "0.5"
       tower-http = { version = "0.6", features = ["cors", "trace"] }
       serde = { version = "1", features = ["derive"] }
       serde_json = "1"
       thiserror = "2"
       uuid = { version = "1", features = ["v4", "serde"] }
       tracing = "0.1"
       tracing-subscriber = "0.3"
       rusqlite = { version = "0.32", features = ["bundled"] }
       ```

       NOTE: `rusqlite` is a direct dependency because Plan 02's undo.rs and service.rs use `rusqlite::Connection` in function signatures and struct fields. `lmlang-storage` does not re-export `rusqlite::Connection`, so `lmlang-server` needs its own dependency to access the type.

    5. Create lib.rs with module declarations:
       ```rust
       pub mod error;
       pub mod schema;
       ```

    6. Verify: `cargo check -p lmlang-check` and `cargo check -p lmlang-server` both succeed.
  </action>
  <verify>`cargo check -p lmlang-check && cargo check -p lmlang-server` succeeds with no errors</verify>
  <done>serde derives added to Value, TraceEntry, RuntimeError, TypeError, FixSuggestion; lmlang-server crate exists in workspace with rusqlite dependency and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Define API schema types and error response system</name>
  <files>
    crates/lmlang-server/src/error.rs
    crates/lmlang-server/src/schema/mod.rs
    crates/lmlang-server/src/schema/mutations.rs
    crates/lmlang-server/src/schema/queries.rs
    crates/lmlang-server/src/schema/diagnostics.rs
    crates/lmlang-server/src/schema/simulate.rs
    crates/lmlang-server/src/schema/history.rs
    crates/lmlang-server/src/schema/programs.rs
    crates/lmlang-server/src/schema/common.rs
    crates/lmlang-server/src/schema/verify.rs
  </files>
  <action>
    1. Create `error.rs` with:
       - `ApiError` enum (thiserror) with variants: NotFound(String), BadRequest(String), ValidationFailed(Vec of DiagnosticError), InternalError(String), Conflict(String).
       - `impl axum::response::IntoResponse for ApiError` returning JSON with appropriate HTTP status codes (404, 400, 422, 500, 409).
       - Response body format: `{ "success": false, "error": { "code": "...", "message": "...", "details": ... } }`.
       - `impl From<lmlang_core::CoreError> for ApiError` mapping core errors to appropriate API errors.
       - `impl From<lmlang_storage::StorageError> for ApiError`.

    2. Create `schema/mod.rs` re-exporting all sub-modules: `pub mod common; pub mod diagnostics; pub mod history; pub mod mutations; pub mod programs; pub mod queries; pub mod simulate; pub mod verify;`.

    3. Create `schema/diagnostics.rs` with:
       - `DiagnosticError { code: String, message: String, details: Option<DiagnosticDetails> }` (Serialize)
       - `DiagnosticWarning { code: String, message: String }` (Serialize)
       - `DiagnosticDetails { source_node: Option<NodeId>, target_node: Option<NodeId>, edge_path: Option<Vec<EdgeId>>, expected_type: Option<TypeId>, actual_type: Option<TypeId>, function_id: Option<FunctionId>, port: Option<u16> }` (Serialize)
       - `impl From<TypeError> for DiagnosticError` converting each TypeError variant to structured error with appropriate code string (TYPE_MISMATCH, MISSING_INPUT, WRONG_INPUT_COUNT, UNKNOWN_TYPE, NON_NUMERIC_ARITHMETIC, NON_BOOLEAN_CONDITION).
       - Per CONTEXT.md locked decision: errors describe the problem only -- no fix suggestions in API output. Do NOT include FixSuggestion in DiagnosticError.

    4. Create `schema/mutations.rs` with:
       - `ProposeEditRequest { mutations: Vec<Mutation>, dry_run: bool }` (Deserialize)
       - `Mutation` enum with serde tag="type": InsertNode { op, owner }, RemoveNode { node_id }, ModifyNode { node_id, new_op }, AddEdge { from, to, source_port, target_port, value_type }, AddControlEdge { from, to, branch_index }, RemoveEdge { edge_id }, AddFunction { name, module, params, return_type, visibility }, AddModule { name, parent, visibility }.
       - `ProposeEditResponse { valid: bool, created: Vec<CreatedEntity>, errors: Vec<DiagnosticError>, warnings: Vec<DiagnosticWarning>, committed: bool }` (Serialize)
       - `CreatedEntity` enum: Node(NodeId), Edge(EdgeId), Function(FunctionId), Module(ModuleId) (Serialize)

    5. Create `schema/queries.rs` with:
       - `DetailLevel` enum: Summary, Standard, Full (Deserialize, default Standard)
       - `NodeView { id, op, owner, op_data, incoming_edges, outgoing_edges }` (Serialize, skip_serializing_if Option::is_none for optional fields)
       - `EdgeView { id, from, to, kind, value_type, source_port, target_port, branch_index }` (Serialize)
       - `FunctionView { id, name, module, params, return_type, visibility, is_closure, node_count }` (Serialize)
       - `ProgramOverviewResponse { program_id, name, modules, functions, node_count, edge_count }` (Serialize)
       - `GetNodeRequest` -- just path params, no body needed
       - `GetFunctionResponse { function: FunctionView, nodes: Vec<NodeView>, edges: Vec<EdgeView> }` (Serialize)
       - `NeighborhoodRequest { node_id, max_hops, detail }` (Deserialize) -- max_hops capped at 3
       - `NeighborhoodResponse { center: NodeId, nodes: Vec<NodeView>, edges: Vec<EdgeView>, hops_used: u32 }` (Serialize)
       - `SearchRequest { filter_type: Option<String>, owner_function: Option<FunctionId>, value_type: Option<TypeId>, detail }` (Deserialize)
       - `SearchResponse { nodes: Vec<NodeView>, total_count: usize }` (Serialize)

    6. Create `schema/simulate.rs` with:
       - `SimulateRequest { function_id: FunctionId, inputs: Vec<serde_json::Value>, trace_enabled: Option<bool> }` (Deserialize)
       - Use serde_json::Value for inputs because the agent doesn't know Rust enum format; service layer converts to interpreter Value.
       - `SimulateResponse { success: bool, result: Option<serde_json::Value>, trace: Option<Vec<TraceEntryView>>, error: Option<DiagnosticError>, io_log: Vec<serde_json::Value> }` (Serialize)
       - `TraceEntryView { node_id: NodeId, op: String, inputs: Vec<(u16, serde_json::Value)>, output: Option<serde_json::Value> }` (Serialize)

    7. Create `schema/history.rs` with:
       - `HistoryEntry { id: String (uuid), timestamp: String, description: Option<String>, undone: bool }` (Serialize)
       - `ListHistoryResponse { entries: Vec<HistoryEntry>, total: usize }` (Serialize)
       - `UndoResponse { success: bool, restored_edit: Option<HistoryEntry> }` (Serialize)
       - `RedoResponse { success: bool, reapplied_edit: Option<HistoryEntry> }` (Serialize)
       - `CreateCheckpointRequest { name: String, description: Option<String> }` (Deserialize)
       - `CreateCheckpointResponse { name: String, timestamp: String }` (Serialize)
       - `ListCheckpointsResponse { checkpoints: Vec<CheckpointView> }` (Serialize)
       - `CheckpointView { name: String, timestamp: String, description: Option<String>, edit_position: i64 }` (Serialize)
       - `RestoreCheckpointResponse { success: bool, name: String }` (Serialize)
       - `DiffRequest { from_checkpoint: Option<String>, to_checkpoint: Option<String> }` (Deserialize)
       - `DiffResponse { added_nodes: Vec<NodeId>, removed_nodes: Vec<NodeId>, modified_nodes: Vec<NodeId>, added_edges: Vec<EdgeId>, removed_edges: Vec<EdgeId> }` (Serialize)

    8. Create `schema/programs.rs` with:
       - `CreateProgramRequest { name: String }` (Deserialize)
       - `CreateProgramResponse { id: ProgramId, name: String }` (Serialize)
       - `ProgramListResponse { programs: Vec<ProgramSummaryView> }` (Serialize)
       - `ProgramSummaryView { id: ProgramId, name: String }` (Serialize)

    9. Create `schema/common.rs` with:
       - `ApiResponse<T: Serialize> { success: bool, data: Option<T>, error: Option<ApiErrorDetail>, warnings: Vec<DiagnosticWarning> }` (Serialize) with skip_serializing_if attributes.
       - Per CONTEXT.md: layered diagnostic format with top-level summary + optional details.

    10. Create `schema/verify.rs` with:
       - `VerifyScope` enum (Deserialize): `Local`, `Full`. Used by ProgramService.verify() in Plan 02's service.rs. This MUST be defined here in the schema layer (not in handlers) so that service.rs can import it at compile time in Wave 2, before handlers exist in Wave 3.
       - `VerifyResponse { valid: bool, errors: Vec<DiagnosticError>, warnings: Vec<DiagnosticWarning> }` (Serialize). Also consumed by service.rs in Plan 02.

    11. Verify compilation: `cargo check -p lmlang-server`.
  </action>
  <verify>`cargo check -p lmlang-server` succeeds; all schema types compile; `cargo test -p lmlang-check` passes (serde derives don't break existing tests)</verify>
  <done>All API request/response types defined including VerifyScope/VerifyResponse in schema/verify.rs, ApiError implements IntoResponse, From<TypeError> for DiagnosticError converts all variants, schema/common.rs with ApiResponse<T>, cargo check succeeds for both lmlang-check and lmlang-server</done>
</task>

</tasks>

<verification>
- `cargo check -p lmlang-check` -- serde derives don't break existing code
- `cargo test -p lmlang-check` -- all 36+ existing tests still pass
- `cargo check -p lmlang-server` -- all schema types and error types compile
- grep for `Serialize` in value.rs, trace.rs, error.rs, diagnostics.rs confirms derives added
</verification>

<success_criteria>
- lmlang-server crate exists in workspace with axum 0.8, tokio, tower-http, serde, uuid, tracing, rusqlite dependencies
- All lmlang-check interpreter types (Value, TraceEntry, RuntimeError) derive Serialize + Deserialize
- All lmlang-check typecheck types (TypeError, FixSuggestion) derive Serialize + Deserialize
- Complete set of API schema types covers: mutations, queries, diagnostics, simulation, history, programs, verify, common
- VerifyScope and VerifyResponse defined in schema/verify.rs (available for Plan 02 service.rs)
- ApiError implements IntoResponse with proper HTTP status codes and JSON body
- From<TypeError> -> DiagnosticError conversion handles all 6 TypeError variants
- `cargo check` across workspace succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-agent-tool-api/04-01-SUMMARY.md`
</output>

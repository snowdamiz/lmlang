---
phase: 03-type-checking-graph-interpreter
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/lmlang-check/Cargo.toml
  - crates/lmlang-check/src/lib.rs
  - crates/lmlang-check/src/typecheck/mod.rs
  - crates/lmlang-check/src/typecheck/rules.rs
  - crates/lmlang-check/src/typecheck/diagnostics.rs
  - crates/lmlang-check/src/typecheck/coercion.rs
autonomous: true
requirements:
  - CNTR-01

must_haves:
  truths:
    - "Adding a data edge with an incompatible type returns a TypeError with the source node, target node, expected type, and actual type"
    - "All type errors in a graph are reported at once by validate_graph (not stop-at-first)"
    - "Bool-to-integer implicit coercion is accepted (true=1, false=0)"
    - "Safe integer widening (i8->i16->i32->i64) and float widening (f32->f64) are accepted"
    - "Nominal struct typing rejects two structs with identical fields but different TypeIds"
    - "Type checker produces actionable fix suggestions when the fix is obvious (e.g., insert a Cast node)"
    - "Every ComputeNodeOp variant has a type rule (no missing match arms)"
  artifacts:
    - path: "crates/lmlang-check/Cargo.toml"
      provides: "Crate definition with lmlang-core, petgraph, thiserror dependencies"
    - path: "crates/lmlang-check/src/typecheck/rules.rs"
      provides: "Per-op type rule resolution for all ~34 op variants"
      contains: "resolve_type_rule"
    - path: "crates/lmlang-check/src/typecheck/diagnostics.rs"
      provides: "TypeError enum with rich context fields and fix suggestions"
      contains: "TypeError"
    - path: "crates/lmlang-check/src/typecheck/coercion.rs"
      provides: "Coercion rules: bool->int, safe widening, &mut T -> &T"
      contains: "can_coerce"
    - path: "crates/lmlang-check/src/typecheck/mod.rs"
      provides: "validate_data_edge and validate_graph public API"
      contains: "validate_data_edge"
  key_links:
    - from: "crates/lmlang-check/src/typecheck/mod.rs"
      to: "crates/lmlang-core/src/graph.rs"
      via: "ProgramGraph immutable reference for edge/node queries"
      pattern: "&ProgramGraph"
    - from: "crates/lmlang-check/src/typecheck/mod.rs"
      to: "crates/lmlang-check/src/typecheck/rules.rs"
      via: "resolve_type_rule called for each target node"
      pattern: "resolve_type_rule"
    - from: "crates/lmlang-check/src/typecheck/rules.rs"
      to: "crates/lmlang-core/src/ops.rs"
      via: "Exhaustive match on ComputeNodeOp variants"
      pattern: "ComputeNodeOp::Core|ComputeNodeOp::Structured"
---

<objective>
Create the lmlang-check crate with a static type checker that verifies edge type compatibility for every op in the computational graph.

Purpose: Enables catching type errors eagerly on every graph edit (CNTR-01), producing rich diagnostics with fix suggestions for AI agent consumption.
Output: Working type checker with per-op rules, coercion logic, validation functions, and comprehensive TDD tests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-checking-graph-interpreter/03-RESEARCH.md
@crates/lmlang-core/src/lib.rs
@crates/lmlang-core/src/ops.rs
@crates/lmlang-core/src/edge.rs
@crates/lmlang-core/src/types.rs
@crates/lmlang-core/src/type_id.rs
@crates/lmlang-core/src/graph.rs
@crates/lmlang-core/src/node.rs
@crates/lmlang-core/src/function.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lmlang-check crate with type error diagnostics, coercion rules, and per-op type rules</name>
  <files>
    crates/lmlang-check/Cargo.toml
    crates/lmlang-check/src/lib.rs
    crates/lmlang-check/src/typecheck/mod.rs
    crates/lmlang-check/src/typecheck/diagnostics.rs
    crates/lmlang-check/src/typecheck/coercion.rs
    crates/lmlang-check/src/typecheck/rules.rs
  </files>
  <action>
    **TDD: Write failing tests first, then implement.**

    **Crate setup:**
    Create `crates/lmlang-check/Cargo.toml` with:
    - `lmlang-core = { path = "../lmlang-core" }`
    - `petgraph = { version = "0.8", features = ["serde-1"] }`
    - `thiserror = "2.0"`
    - `[dev-dependencies]` proptest = "1.10"

    Create `crates/lmlang-check/src/lib.rs` with `pub mod typecheck;` (and later `pub mod interpreter;` added in plan 02).

    **diagnostics.rs — TypeError enum with thiserror:**
    ```rust
    #[derive(Debug, thiserror::Error)]
    pub enum TypeError {
        #[error("type mismatch at node {target_node}: port {target_port} expects {expected}, got {actual}")]
        TypeMismatch {
            source_node: NodeId,
            target_node: NodeId,
            source_port: u16,
            target_port: u16,
            expected: TypeId,
            actual: TypeId,
            function_id: FunctionId,
            /// Suggested fix, if one is obvious
            suggestion: Option<FixSuggestion>,
        },
        #[error("missing input: node {node} port {port} has no incoming data edge")]
        MissingInput {
            node: NodeId,
            port: u16,
            function_id: FunctionId,
        },
        #[error("unexpected input count: node {node} expects {expected} inputs, got {actual}")]
        WrongInputCount {
            node: NodeId,
            expected: usize,
            actual: usize,
            function_id: FunctionId,
        },
        #[error("unknown type: {type_id} not found in registry")]
        UnknownType { type_id: TypeId },
        #[error("non-numeric type {type_id} used in arithmetic operation at node {node}")]
        NonNumericArithmetic {
            node: NodeId,
            type_id: TypeId,
            function_id: FunctionId,
        },
        #[error("non-boolean condition at node {node}: expected Bool, got {actual}")]
        NonBooleanCondition {
            node: NodeId,
            actual: TypeId,
            function_id: FunctionId,
        },
    }

    #[derive(Debug, Clone)]
    pub enum FixSuggestion {
        InsertCast { from: TypeId, to: TypeId },
        // Future suggestions can be added here
    }
    ```

    **coercion.rs — Type coercion and widening rules:**
    Implement:
    - `can_coerce(from: TypeId, to: TypeId, registry: &TypeRegistry) -> bool` — returns true if `from` can implicitly convert to `to`
    - Coercion rules (per user decisions + discretion):
      - Bool -> any integer type (true=1, false=0) [LOCKED]
      - Safe integer widening: i8->i16->i32->i64 (lossless, same sign family)
      - Safe float widening: f32->f64
      - NO implicit int->float or float->int (requires explicit Cast)
      - NO narrowing conversions
      - &mut T -> &T allowed (not reverse) [per discretion recommendation]
    - `is_numeric(type_id: TypeId) -> bool` — returns true for I8/I16/I32/I64/F32/F64
    - `is_integer(type_id: TypeId) -> bool` — returns true for I8/I16/I32/I64
    - `is_float(type_id: TypeId) -> bool` — returns true for F32/F64
    - `common_numeric_type(a: TypeId, b: TypeId, registry: &TypeRegistry) -> Option<TypeId>` — finds the wider of two numeric types if one can widen to the other

    **rules.rs — Per-op type rule resolution:**
    Implement `resolve_type_rule(op: &ComputeNodeOp, input_types: &[(u16, TypeId)], registry: &TypeRegistry) -> Result<OpTypeRule, TypeError>` with exhaustive match on all op variants.

    The `OpTypeRule` struct:
    ```rust
    pub struct OpTypeRule {
        pub expected_inputs: Vec<(u16, TypeId)>,  // port -> expected type
        pub output_type: Option<TypeId>,           // None for void ops (Store, Return)
    }
    ```

    Type rules per op category (exhaustive, NO wildcard match arms):
    - **Const { value }**: 0 inputs, output = type matching the ConstValue variant (Bool->BOOL, I32->I32, etc.)
    - **BinaryArith { op }**: 2 inputs (ports 0,1), both must be same numeric type (after coercion), output = that type. Bool inputs coerced to I8 for arithmetic.
    - **UnaryArith { op }**: 1 input (port 0), must be numeric, output = same type
    - **Compare { op }**: 2 inputs (ports 0,1), both must be same type (after coercion), output = BOOL
    - **BinaryLogic { op }**: 2 inputs (ports 0,1), both must be Bool (or integer for bitwise), output = same type
    - **Not**: 1 input (port 0), must be Bool or integer, output = same type
    - **Shift { op }**: 2 inputs (port 0 = value integer, port 1 = shift amount integer), output = type of port 0
    - **IfElse**: 1 data input (port 0 = condition, Bool). Output type determined by branch results (not checked here -- branches are via control edges).
    - **Loop**: 1 data input (port 0 = initial value). Output = same type.
    - **Match**: 1 data input (port 0 = discriminant, integer or enum). No output (branch selection).
    - **Branch**: 1 data input (port 0 = condition, Bool). No output.
    - **Jump**: 0 data inputs. No output.
    - **Phi**: N data inputs, all must be same type. Output = that type.
    - **Alloc**: 0 data inputs. Output = Pointer type (mutable).
    - **Load**: 1 data input (port 0 = pointer). Output = pointee type.
    - **Store**: 2 data inputs (port 0 = pointer, port 1 = value). Value type must match pointee type. No output.
    - **GetElementPtr**: 2 data inputs (port 0 = pointer to aggregate, port 1 = index, integer). Output = pointer to element.
    - **Call { target }**: N data inputs matching target function's parameter types. Output = function's return type. Look up FunctionDef via target FunctionId from the graph.
    - **IndirectCall**: port 0 = function pointer, remaining ports = arguments. Output = return type from function type.
    - **Return**: 0 or 1 data input. No output.
    - **Parameter { index }**: 0 data inputs. Output = parameter type from FunctionDef.
    - **Print**: 1 data input (any type). No output (Unit).
    - **ReadLine**: 0 data inputs. Output = string-like (I8 array or pointer -- use I64 as placeholder since no string type yet).
    - **FileOpen/FileRead/FileWrite/FileClose**: Handle as runtime/opaque. Accept inputs, produce appropriate outputs.
    - **MakeClosure { function }**: N data inputs (captured values). Output = function type.
    - **CaptureAccess { index }**: 0 data inputs. Output = captured variable type from FunctionDef.
    - **StructCreate { type_id }**: N inputs matching struct fields. Output = the struct type.
    - **StructGet { field_index }**: 1 input (port 0 = struct value). Output = field type at field_index.
    - **StructSet { field_index }**: 2 inputs (port 0 = struct, port 1 = new field value matching field type). Output = same struct type.
    - **ArrayCreate { length }**: N inputs all same type. Output = array type.
    - **ArrayGet**: 2 inputs (port 0 = array, port 1 = index integer). Output = element type.
    - **ArraySet**: 3 inputs (port 0 = array, port 1 = index, port 2 = new element). Output = same array type.
    - **Cast { target_type }**: 1 input (any numeric/pointer type). Output = target_type.
    - **EnumCreate { type_id, variant_index }**: 0 or 1 input (variant payload). Output = enum type.
    - **EnumDiscriminant**: 1 input (enum value). Output = I32 (discriminant integer).
    - **EnumPayload { variant_index }**: 1 input (enum value). Output = variant payload type.

    For ops that need function/type context, `resolve_type_rule` takes `&ProgramGraph` as an additional parameter to look up FunctionDefs and types from the registry.

    **Tests (RED first, then GREEN):**
    - Test every op category has a working type rule (construct a minimal ProgramGraph, create the op, verify rule resolution)
    - Test type mismatch detection: add edge with wrong type, verify TypeError::TypeMismatch returned
    - Test coercion: i32 edge to i64 port should succeed via widening
    - Test coercion: bool edge to i32 arithmetic port should succeed
    - Test coercion: i64 edge to i32 port should FAIL (narrowing not allowed)
    - Test nominal typing: two different struct TypeIds with same fields should not be interchangeable
    - Test fix suggestion: when types differ but a Cast could fix it, suggestion is InsertCast
    - Test Const output type matches ConstValue variant
    - Test BinaryArith with mismatched operand types returns error
    - Test Call with wrong number of arguments returns WrongInputCount
    - Test Parameter output type matches FunctionDef
  </action>
  <verify>
    `cargo test -p lmlang-check` -- all type rule and coercion tests pass
  </verify>
  <done>
    Every ComputeNodeOp variant has a type rule. Coercion handles bool->int, safe widening, &mut->& per decisions. TypeError provides rich diagnostics with node IDs, types, function context, and fix suggestions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement validate_data_edge and validate_graph public API with comprehensive tests</name>
  <files>
    crates/lmlang-check/src/typecheck/mod.rs
  </files>
  <action>
    **TDD: Write failing tests first, then implement.**

    **validate_data_edge — single edge validation (eager check):**
    ```rust
    pub fn validate_data_edge(
        graph: &ProgramGraph,
        from: NodeId,
        to: NodeId,
        source_port: u16,
        target_port: u16,
        value_type: TypeId,
    ) -> Result<(), Vec<TypeError>>
    ```
    - Look up the target node's op via `graph.get_compute_node(to)`
    - Gather existing incoming edges to the target node via `graph.compute().edges_directed(to.into(), Direction::Incoming)` filtering for data edges
    - Add the proposed new edge to the input set
    - Call `resolve_type_rule` for the target op with the combined input types
    - Check if `value_type` is compatible with the expected type at `target_port` (exact match or coercible via `can_coerce`)
    - If mismatch, generate TypeError with fix suggestion (InsertCast if both are numeric)
    - Return all errors found (not just first)

    **validate_graph — full graph validation (all errors at once):**
    ```rust
    pub fn validate_graph(graph: &ProgramGraph) -> Vec<TypeError>
    ```
    - Iterate over all compute nodes in the graph
    - For each node: gather all incoming data edges, resolve type rule, check each edge's value_type against expected type
    - Also check that nodes requiring inputs have the correct number of incoming data edges (e.g., BinaryArith needs exactly 2)
    - Collect ALL errors across all nodes, do NOT stop at first error [LOCKED decision]
    - Return the full error list (empty = valid graph)

    **Helper: incoming_data_types:**
    ```rust
    fn incoming_data_types(graph: &ProgramGraph, node_id: NodeId) -> Vec<(u16, TypeId)>
    ```
    Uses `graph.compute().edges_directed(node_idx, Direction::Incoming)` to collect `(target_port, value_type)` from all data edges targeting this node.

    **Tests (RED first, then GREEN):**
    - Test validate_data_edge on a valid i32+i32 BinaryArith: returns Ok
    - Test validate_data_edge on i32+f64 BinaryArith: returns TypeError::TypeMismatch
    - Test validate_data_edge on bool+i32 BinaryArith: returns Ok (bool coerces to integer)
    - Test validate_data_edge generates InsertCast suggestion when i32 vs i64 mismatch
    - Test validate_graph on a fully valid "add(a, b)" function graph: returns empty vec
    - Test validate_graph on graph with multiple errors: returns ALL errors (at least 2)
    - Test validate_graph detects missing inputs (node with 0 incoming edges that expects 2)
    - Test validate_graph on multi-function graph: checks all functions
    - Build a graph with: Const(I32) -> BinaryArith + Const(F64) -> BinaryArith, validate_graph returns 1 mismatch error
    - Build a graph with correct Return type matching function's return_type
    - Test that validate_graph reports errors for EVERY invalid edge, not just the first one found
  </action>
  <verify>
    `cargo test -p lmlang-check` -- all validation API tests pass, including multi-error collection
  </verify>
  <done>
    validate_data_edge checks a single proposed edge for type compatibility. validate_graph scans the entire graph and reports ALL type errors at once. Both produce rich TypeErrors with node context and fix suggestions. Callers can use validate_data_edge before add_data_edge for eager checking on every edit.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p lmlang-check` -- all tests pass
2. `cargo build -p lmlang-check` -- compiles with no warnings
3. Every ComputeNodeOp variant is covered in rules.rs match (no wildcards)
4. validate_graph on a valid graph returns empty vec
5. validate_graph on an invalid graph returns multiple errors
6. Bool-to-int coercion, safe widening, and &mut->& coercion all tested
</verification>

<success_criteria>
- lmlang-check crate exists with typecheck module
- All ~34 op variants have exhaustive type rules
- Coercion rules handle bool->int, i8->i16->i32->i64, f32->f64, &mut T -> &T
- TypeError enum has rich diagnostic fields (nodes, ports, types, function, suggestions)
- validate_data_edge enables eager per-edit type checking
- validate_graph reports all errors at once (no stop-at-first)
- Fix suggestions generated for obvious cases (Cast insertion)
- All tests pass via `cargo test -p lmlang-check`
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-checking-graph-interpreter/03-01-SUMMARY.md`
</output>

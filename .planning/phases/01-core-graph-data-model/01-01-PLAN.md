---
phase: 01-core-graph-data-model
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/lmlang-core/Cargo.toml
  - crates/lmlang-core/src/lib.rs
  - crates/lmlang-core/src/types.rs
  - crates/lmlang-core/src/type_id.rs
  - crates/lmlang-core/src/id.rs
  - crates/lmlang-core/src/error.rs
autonomous: true
requirements:
  - GRAPH-05

must_haves:
  truths:
    - "TypeId provides O(1) nominal identity comparison for all types"
    - "LmType enum covers scalars (i8-i64, f32/f64, bool), arrays, structs, enums/tagged unions, pointers, function signatures, Unit, and Never"
    - "StructDef and EnumDef use IndexMap for insertion-ordered fields/variants"
    - "TypeRegistry can register named types and look them up by TypeId"
    - "All core ID types (NodeId, EdgeId, FunctionId, ModuleId, TypeId) are distinct newtype wrappers"
  artifacts:
    - path: "crates/lmlang-core/src/types.rs"
      provides: "LmType, ScalarType, StructDef, EnumDef, EnumVariant, Visibility"
      contains: "enum LmType"
    - path: "crates/lmlang-core/src/type_id.rs"
      provides: "TypeId, TypeRegistry"
      contains: "struct TypeRegistry"
    - path: "crates/lmlang-core/src/id.rs"
      provides: "NodeId, EdgeId, FunctionId, ModuleId"
      contains: "struct FunctionId"
    - path: "crates/lmlang-core/src/error.rs"
      provides: "CoreError enum"
      contains: "enum CoreError"
    - path: "Cargo.toml"
      provides: "Workspace root"
      contains: "workspace"
    - path: "crates/lmlang-core/Cargo.toml"
      provides: "lmlang-core crate dependencies"
      contains: "petgraph"
  key_links:
    - from: "crates/lmlang-core/src/types.rs"
      to: "crates/lmlang-core/src/type_id.rs"
      via: "TypeId used in LmType variants"
      pattern: "TypeId"
    - from: "crates/lmlang-core/src/types.rs"
      to: "crates/lmlang-core/src/id.rs"
      via: "ModuleId used in StructDef/EnumDef"
      pattern: "ModuleId"
---

<objective>
Set up the Cargo workspace and implement the complete type system for lmlang-core.

Purpose: Every other module (ops, edges, functions, modules, graph) depends on these foundational types. This must land first so Wave 2 plans can build on stable type definitions.

Output: Working Cargo workspace with lmlang-core crate containing the full type system, type registry, ID newtypes, and error types. `cargo build` and `cargo test` pass.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-graph-data-model/01-CONTEXT.md
@.planning/phases/01-core-graph-data-model/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cargo workspace and lmlang-core crate</name>
  <files>
    Cargo.toml
    crates/lmlang-core/Cargo.toml
    crates/lmlang-core/src/lib.rs
  </files>
  <action>
Create the Cargo workspace root at `Cargo.toml` with:
```toml
[workspace]
members = ["crates/*"]
resolver = "2"
```

Create `crates/lmlang-core/Cargo.toml` with the exact dependencies from RESEARCH.md:
```toml
[package]
name = "lmlang-core"
version = "0.1.0"
edition = "2021"

[dependencies]
petgraph = { version = "0.8", features = ["serde-1"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "2.0"
smallvec = { version = "1", features = ["serde"] }
indexmap = { version = "2", features = ["serde"] }

[dev-dependencies]
proptest = "1.10"
insta = { version = "1", features = ["json"] }
```

Create a minimal `crates/lmlang-core/src/lib.rs` with module declarations (modules will be empty stubs initially):
```rust
pub mod types;
pub mod type_id;
pub mod id;
pub mod error;
```

Run `cargo build` to verify the workspace compiles and all dependencies resolve.
  </action>
  <verify>`cargo build` succeeds with no errors from the workspace root.</verify>
  <done>Cargo workspace exists with lmlang-core crate, all dependencies resolve, `cargo build` passes.</done>
</task>

<task type="auto">
  <name>Task 2: Implement type system, type registry, IDs, and error types</name>
  <files>
    crates/lmlang-core/src/types.rs
    crates/lmlang-core/src/type_id.rs
    crates/lmlang-core/src/id.rs
    crates/lmlang-core/src/error.rs
    crates/lmlang-core/src/lib.rs
  </files>
  <action>
**id.rs** -- Stable ID newtypes. All derive `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`. Use newtype pattern over `u32`:
- `NodeId(pub u32)` -- stable node index (maps to petgraph NodeIndex)
- `EdgeId(pub u32)` -- stable edge index
- `FunctionId(pub u32)` -- function identity
- `ModuleId(pub u32)` -- module identity
- Implement `Display` for each (just prints the inner value).
- Implement `From<NodeIndex<u32>>` for `NodeId` and `From<NodeId>` for `NodeIndex<u32>` to bridge with petgraph.

**types.rs** -- Full type system per RESEARCH.md code examples and user decisions:
- `ScalarType` enum: `Bool, I8, I16, I32, I64, F32, F64` (no unsigned -- follow LLVM approach per research open question recommendation).
- `LmType` enum with variants:
  - `Scalar(ScalarType)`
  - `Array { element: TypeId, length: u32 }`
  - `Struct(StructDef)`
  - `Enum(EnumDef)`
  - `Pointer { pointee: TypeId, mutable: bool }`
  - `Function { params: Vec<TypeId>, return_type: TypeId }`
  - `Unit`
  - `Never`
- `StructDef`: `name: String, type_id: TypeId, fields: IndexMap<String, TypeId>, module: ModuleId, visibility: Visibility`
- `EnumDef`: `name: String, type_id: TypeId, variants: IndexMap<String, EnumVariant>, module: ModuleId, visibility: Visibility`
- `EnumVariant`: `index: u32, payload: Option<TypeId>`
- `Visibility` enum: `Public, Private` (two-level per user decision)
- All types derive `Debug, Clone, Serialize, Deserialize`. ScalarType and Visibility also derive `Copy, PartialEq, Eq`.
- Include a `ConstValue` enum for constant literal values: `Bool(bool), I8(i8), I16(i16), I32(i32), I64(i64), F32(f64), F64(f64), Unit` -- this is needed by the Const op node. F32 stores as f64 internally to avoid floating-point comparison issues in the enum (add a comment explaining this).

**type_id.rs** -- TypeId and TypeRegistry for nominal typing:
- `TypeId(pub u32)` with `Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize`.
- `TypeRegistry` struct containing:
  - `types: Vec<LmType>` (indexed by TypeId.0)
  - `names: HashMap<String, TypeId>` (lookup by name for structs/enums)
  - `next_id: u32`
- Methods on TypeRegistry:
  - `new() -> Self` -- creates registry with built-in scalar types pre-registered (Bool as TypeId(0), I8 as TypeId(1), ..., F64 as TypeId(6), Unit as TypeId(7), Never as TypeId(8))
  - `register(&mut self, ty: LmType) -> TypeId` -- adds type, returns new TypeId
  - `register_named(&mut self, name: &str, ty: LmType) -> Result<TypeId, CoreError>` -- registers with name, errors on duplicate name
  - `get(&self, id: TypeId) -> Option<&LmType>` -- lookup by ID
  - `get_by_name(&self, name: &str) -> Option<TypeId>` -- lookup by name
  - `scalar_type_id(&self, scalar: ScalarType) -> TypeId` -- returns the pre-registered TypeId for a scalar
  - `unit_type_id(&self) -> TypeId` -- returns pre-registered Unit TypeId
  - `never_type_id(&self) -> TypeId` -- returns pre-registered Never TypeId

**error.rs** -- Core error types using thiserror:
- `CoreError` enum with:
  - `DuplicateTypeName { name: String }` -- trying to register a name that already exists
  - `TypeNotFound { id: TypeId }` -- TypeId not in registry
  - `NodeNotFound { id: NodeId }` -- node index not in graph
  - `FunctionNotFound { id: FunctionId }` -- function ID not found
  - `ModuleNotFound { id: ModuleId }` -- module ID not found
  - `InvalidEdge { reason: String }` -- edge validation failure
  - `GraphInconsistency { reason: String }` -- dual-graph invariant violation

**lib.rs** -- Update to re-export key types:
```rust
pub mod types;
pub mod type_id;
pub mod id;
pub mod error;

// Re-export commonly used types
pub use types::{LmType, ScalarType, ConstValue, Visibility, StructDef, EnumDef, EnumVariant};
pub use type_id::{TypeId, TypeRegistry};
pub use id::{NodeId, EdgeId, FunctionId, ModuleId};
pub use error::CoreError;
```

Write unit tests in each module:
- `type_id.rs`: Test that `TypeRegistry::new()` pre-registers 9 built-in types (7 scalars + Unit + Never), test `register_named` returns unique IDs, test duplicate name returns error, test `get` and `get_by_name` round-trip.
- `id.rs`: Test `From<NodeIndex>` for `NodeId` round-trips correctly.
- `types.rs`: Test that all LmType variants can be created, test serde round-trip (serialize to JSON, deserialize back, compare).
  </action>
  <verify>`cargo test` passes all tests. `cargo build` succeeds with no warnings (add `#[allow(dead_code)]` only if truly needed for types not yet consumed by later modules).</verify>
  <done>Type system is complete: LmType covers all required types (scalars, arrays, structs, enums, pointers, function sigs, Unit, Never). TypeRegistry provides nominal typing with O(1) lookup. All ID newtypes are distinct. Tests prove round-trip correctness.</done>
</task>

</tasks>

<verification>
- `cargo build` compiles the workspace with no errors
- `cargo test` passes all unit tests
- TypeRegistry pre-registers 9 built-in types on `new()`
- LmType enum has exactly 8 variants matching GRAPH-05 requirements
- All types derive Serialize + Deserialize for future storage/API use
- No `String`-based type comparison anywhere -- all nominal via TypeId
</verification>

<success_criteria>
- The lmlang-core crate builds and tests pass
- Type system supports: scalars (Bool, I8-I64, F32, F64), arrays, structs (nominal, ordered fields), enums/tagged unions (nominal, with payloads), pointers (mutable/immutable), function signatures, Unit, Never
- TypeRegistry provides `register`, `register_named`, `get`, `get_by_name` with pre-registered built-ins
- All ID types are distinct newtypes with serde support
- CoreError enum covers all anticipated failure modes
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-graph-data-model/01-01-SUMMARY.md`
</output>

---
phase: 01-core-graph-data-model
plan: 04
type: execute
wave: 4
depends_on:
  - 01-02
  - 01-03
files_modified:
  - crates/lmlang-core/src/graph.rs
  - crates/lmlang-core/src/lib.rs
autonomous: true
requirements:
  - DUAL-02
  - DUAL-03

must_haves:
  truths:
    - "ProgramGraph contains two separate StableGraph instances (compute + semantic) per DUAL-03"
    - "The computational graph stores ComputeNode with FlowEdge per DUAL-02"
    - "The semantic graph stores SemanticNode with SemanticEdge as a lightweight structural mirror"
    - "Functions added via ProgramGraph methods create nodes in BOTH graphs atomically"
    - "Graph mutations go through ProgramGraph methods -- raw StableGraph access is not publicly exposed for mutation"
    - "A simple program (constants, arithmetic, function call) can be constructed and its structure verified"
  artifacts:
    - path: "crates/lmlang-core/src/graph.rs"
      provides: "ProgramGraph dual-graph container with builder API"
      contains: "struct ProgramGraph"
      min_lines: 150
  key_links:
    - from: "crates/lmlang-core/src/graph.rs"
      to: "crates/lmlang-core/src/node.rs"
      via: "StableGraph<ComputeNode, FlowEdge> and StableGraph<SemanticNode, SemanticEdge>"
      pattern: "StableGraph.*ComputeNode"
    - from: "crates/lmlang-core/src/graph.rs"
      to: "crates/lmlang-core/src/function.rs"
      via: "FunctionDef stored in functions HashMap"
      pattern: "FunctionDef"
    - from: "crates/lmlang-core/src/graph.rs"
      to: "crates/lmlang-core/src/module.rs"
      via: "ModuleTree for module hierarchy"
      pattern: "ModuleTree"
    - from: "crates/lmlang-core/src/graph.rs"
      to: "crates/lmlang-core/src/type_id.rs"
      via: "TypeRegistry for nominal type system"
      pattern: "TypeRegistry"
---

<objective>
Implement the ProgramGraph dual-graph container that ties together the computational and semantic graphs, with a builder API for constructing programs and an integration test proving the data model works end-to-end.

Purpose: This is the capstone of Phase 1. ProgramGraph is the single entry point for constructing and querying programs. It enforces dual-graph consistency (DUAL-03), stores the executable computational graph (DUAL-02), and provides the API that all future phases (storage, type checking, agent tools, compilation) will use. The integration test proves the entire data model is coherent.

Output: ProgramGraph struct with builder methods, semantic auto-sync for structural changes, and a comprehensive integration test constructing a multi-function program with closures.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-graph-data-model/01-CONTEXT.md
@.planning/phases/01-core-graph-data-model/01-RESEARCH.md
@.planning/phases/01-core-graph-data-model/01-01-SUMMARY.md
@.planning/phases/01-core-graph-data-model/01-02-SUMMARY.md
@.planning/phases/01-core-graph-data-model/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ProgramGraph dual-graph container with builder API</name>
  <files>
    crates/lmlang-core/src/graph.rs
    crates/lmlang-core/src/lib.rs
  </files>
  <action>
**graph.rs** -- The core ProgramGraph struct per RESEARCH.md Pattern 1:

```rust
pub struct ProgramGraph {
    /// Layer 2: Executable Computational Graph
    compute: StableGraph<ComputeNode, FlowEdge, Directed>,
    /// Layer 1: Semantic skeleton
    semantic: StableGraph<SemanticNode, SemanticEdge, Directed>,
    /// Type registry for nominal type identity
    pub types: TypeRegistry,
    /// Module hierarchy
    pub modules: ModuleTree,
    /// Function definitions indexed by FunctionId
    functions: HashMap<FunctionId, FunctionDef>,
    /// Next function ID counter
    next_function_id: u32,
}
```

Note: `compute` and `semantic` are PRIVATE. All mutations go through ProgramGraph methods to maintain dual-graph consistency (per RESEARCH.md Pitfall 3). Provide read-only accessors `compute(&self)` and `semantic(&self)` returning `&StableGraph<...>` for traversals and queries.

**Constructor:**
- `ProgramGraph::new(root_module_name: &str) -> Self` -- creates both empty graphs, a TypeRegistry with built-ins, a ModuleTree with root, empty functions map.

**Module methods:**
- `add_module(&mut self, name: String, parent: ModuleId, visibility: Visibility) -> Result<ModuleId, CoreError>` -- delegates to ModuleTree. Also adds a SemanticNode::Module to the semantic graph and a Contains edge from parent module's semantic node to the new module's semantic node. The root module should have a semantic node created in `new()`.

**Function methods (auto-sync: creates semantic node automatically):**
- `add_function(&mut self, name: String, module: ModuleId, params: Vec<(String, TypeId)>, return_type: TypeId, visibility: Visibility) -> Result<FunctionId, CoreError>` -- creates FunctionDef, stores it, adds SemanticNode::Function to semantic graph with a Contains edge from the module's semantic node, registers in ModuleTree. Returns FunctionId.
- `add_closure(&mut self, name: String, module: ModuleId, parent: FunctionId, params: Vec<(String, TypeId)>, return_type: TypeId, captures: Vec<Capture>) -> Result<FunctionId, CoreError>` -- like add_function but creates a closure FunctionDef with is_closure=true, parent_function set, captures filled.
- `get_function(&self, id: FunctionId) -> Option<&FunctionDef>` -- lookup.
- `get_function_mut(&mut self, id: FunctionId) -> Option<&mut FunctionDef>` -- mutable lookup (for setting entry_node after body is built).

**Compute node methods:**
- `add_compute_node(&mut self, op: ComputeNodeOp, owner: FunctionId) -> Result<NodeId, CoreError>` -- adds ComputeNode to compute graph. Returns NodeId. Errors if owner function doesn't exist. Does NOT add a semantic node (individual ops don't need semantic entries per RESEARCH.md Pattern 1 implementation note).
- `add_core_op(&mut self, op: ComputeOp, owner: FunctionId) -> Result<NodeId, CoreError>` -- convenience wrapper.
- `add_structured_op(&mut self, op: StructuredOp, owner: FunctionId) -> Result<NodeId, CoreError>` -- convenience wrapper.
- `remove_compute_node(&mut self, id: NodeId) -> Result<ComputeNode, CoreError>` -- removes node and all connected edges. Errors if not found.
- `get_compute_node(&self, id: NodeId) -> Option<&ComputeNode>` -- lookup.

**Edge methods:**
- `add_data_edge(&mut self, from: NodeId, to: NodeId, source_port: u16, target_port: u16, value_type: TypeId) -> Result<EdgeId, CoreError>` -- adds FlowEdge::Data to compute graph. Returns EdgeId. Basic validation: both nodes must exist.
- `add_control_edge(&mut self, from: NodeId, to: NodeId, branch_index: Option<u16>) -> Result<EdgeId, CoreError>` -- adds FlowEdge::Control to compute graph.
- `remove_edge(&mut self, id: EdgeId) -> Result<FlowEdge, CoreError>` -- removes edge.

**Query methods:**
- `function_nodes(&self, id: FunctionId) -> Vec<NodeId>` -- returns all compute nodes owned by a function. Iterates compute graph filtering by owner. (Could optimize later with an index.)
- `node_count(&self) -> usize` -- compute graph node count.
- `edge_count(&self) -> usize` -- compute graph edge count.
- `function_count(&self) -> usize` -- number of functions.

**Semantic query methods:**
- `semantic_node_count(&self) -> usize`
- `semantic_edge_count(&self) -> usize`

**Debug assertion for consistency (cfg(debug_assertions) only):**
- `assert_consistency(&self)` -- verifies that every FunctionId in the functions map has a corresponding SemanticNode::Function in the semantic graph. Called at the end of `add_function` and `add_closure` in debug builds.

**Derive serde for ProgramGraph:**
ProgramGraph should derive `Serialize, Deserialize` to support future storage (Phase 2). This requires that all contained types (StableGraph with its contents, TypeRegistry, ModuleTree, HashMap<FunctionId, FunctionDef>) are serializable -- which they are since we derived serde on everything.

**lib.rs** -- Add graph module and re-export:
```rust
pub mod graph;
pub use graph::ProgramGraph;
```

Write unit tests in graph.rs:
- Test creating a ProgramGraph, adding a module, adding a function, adding compute nodes, adding data edges. Verify node/edge counts.
- Test that adding a function creates a semantic node (semantic_node_count increases).
- Test that adding compute nodes does NOT create semantic nodes.
- Test add_compute_node with nonexistent owner returns error.
- Test remove_compute_node removes the node and its edges.
  </action>
  <verify>`cargo test` passes. `cargo build` compiles. ProgramGraph has both StableGraph instances. Verify with a quick test that a function + 3 compute nodes + 2 edges can be created without errors.</verify>
  <done>ProgramGraph provides the dual-graph container with separate compute and semantic StableGraphs. All mutations maintain consistency. Functions auto-create semantic nodes. Compute nodes do not create semantic nodes. Basic CRUD operations work for nodes and edges.</done>
</task>

<task type="auto">
  <name>Task 2: Integration test -- construct a multi-function program</name>
  <files>
    crates/lmlang-core/src/graph.rs
  </files>
  <action>
Add a comprehensive integration test at the bottom of graph.rs (in a `#[cfg(test)] mod tests` block, or as a separate test within the existing tests module) that constructs a complete small program and verifies the entire data model works together.

**The test program to represent: "add_offset" with a closure**

Pseudocode:
```
module main {
    fn add(a: i32, b: i32) -> i32 {
        return a + b;
    }

    fn make_adder(offset: i32) -> fn(i32) -> i32 {
        // closure capturing offset
        let adder = |x: i32| -> i32 { add(x, offset) };
        return adder;
    }
}
```

**Test steps:**

1. Create ProgramGraph with root module "main".
2. Register no custom types (just use built-in I32).
3. Get the i32 TypeId from the type registry: `graph.types.scalar_type_id(ScalarType::I32)`.
4. Add function "add" to root module with params [("a", i32_id), ("b", i32_id)], return_type i32_id.
5. Build the body of "add":
   - `param_a = add_core_op(Parameter { index: 0 }, add_fn_id)`
   - `param_b = add_core_op(Parameter { index: 1 }, add_fn_id)`
   - `sum = add_core_op(BinaryArith { op: ArithOp::Add }, add_fn_id)`
   - `ret = add_core_op(Return, add_fn_id)`
   - Data edge: param_a -> sum (port 0 -> port 0, type i32)
   - Data edge: param_b -> sum (port 0 -> port 1, type i32)
   - Data edge: sum -> ret (port 0 -> port 0, type i32)
   - Set entry_node on add function.
6. Add function "make_adder" to root module with params [("offset", i32_id)], return type as a function type (register Function { params: [i32_id], return_type: i32_id } in TypeRegistry).
7. Add closure "adder" with parent make_adder, captures: [Capture { name: "offset", captured_type: i32_id, mode: ByValue }], params [("x", i32_id)], return i32.
8. Build the closure body:
   - `param_x = add_core_op(Parameter { index: 0 }, adder_fn_id)`
   - `cap_offset = add_core_op(CaptureAccess { index: 0 }, adder_fn_id)`
   - `call_add = add_core_op(Call { target: add_fn_id }, adder_fn_id)`
   - `ret = add_core_op(Return, adder_fn_id)`
   - Data edges: param_x -> call_add (port 0 -> 0), cap_offset -> call_add (port 0 -> 1), call_add -> ret (port 0 -> 0). All typed i32.
9. Build make_adder body:
   - `param_offset = add_core_op(Parameter { index: 0 }, make_adder_id)`
   - `make_closure = add_core_op(MakeClosure { function: adder_fn_id }, make_adder_id)`
   - `ret = add_core_op(Return, make_adder_id)`
   - Data edge: param_offset -> make_closure (port 0 -> 0, i32 -- the captured value)
   - Data edge: make_closure -> ret (port 0 -> 0, fn type)

**Assertions:**
- `graph.function_count() == 3` (add, make_adder, adder closure)
- `graph.node_count() == 11` (3 in add + 4 in adder + 3 in make_adder + 1 extra... count carefully based on above)
  Actually count: add has 4 nodes (param_a, param_b, sum, ret), adder has 4 nodes (param_x, cap_offset, call_add, ret), make_adder has 3 nodes (param_offset, make_closure, ret) = 11 total.
- `graph.edge_count() == 8` (3 in add + 3 in adder + 2 in make_adder)
- Verify function_nodes(add_fn_id) returns exactly 4 NodeIds.
- Verify the adder closure: `get_function(adder_fn_id).unwrap().is_closure == true`
- Verify `get_function(adder_fn_id).unwrap().captures.len() == 1`
- Verify `get_function(adder_fn_id).unwrap().parent_function == Some(make_adder_id)`
- Semantic graph checks:
  - `graph.semantic_node_count() >= 4` (root module + add function + make_adder function + adder closure) -- might be more if modules create semantic nodes.
  - The semantic graph has Contains edges from root module to each function.
- Verify serde round-trip: serialize ProgramGraph to JSON, deserialize back, verify node_count and function_count match.

**Name the test:** `test_multi_function_program_with_closure`

This test proves the ENTIRE Phase 1 data model works: types, ops, edges, nodes, functions with closures, modules, and the dual-graph container.
  </action>
  <verify>`cargo test test_multi_function_program_with_closure` passes. The test constructs 3 functions (including a closure), 11 compute nodes, 8 edges, and verifies structure, ownership, and serde round-trip.</verify>
  <done>A complete multi-function program with a closure can be constructed using the ProgramGraph API. The program includes arithmetic, function calls, closure captures, and cross-function references. Serde round-trip preserves the entire structure. The Phase 1 data model is proven coherent end-to-end.</done>
</task>

</tasks>

<verification>
- `cargo build` and `cargo test` pass (all tests including integration)
- ProgramGraph contains two SEPARATE StableGraph instances (not one heterogeneous graph)
- Compute graph uses StableGraph<ComputeNode, FlowEdge, Directed>
- Semantic graph uses StableGraph<SemanticNode, SemanticEdge, Directed>
- Adding a function creates nodes in BOTH graphs (semantic auto-sync)
- Adding compute nodes only touches the compute graph
- Raw StableGraph mutation is not publicly exposed (only ProgramGraph methods)
- Integration test constructs a complete program with functions, closures, arithmetic, and cross-function calls
- Serde round-trip preserves the full ProgramGraph
</verification>

<success_criteria>
- ProgramGraph implements DUAL-02 (executable computational graph with typed ops + data/control flow)
- ProgramGraph implements DUAL-03 (two separate StableGraph instances with cross-references via shared ID space)
- A multi-function program with closures can be constructed and verified
- The entire data model serializes/deserializes correctly
- All Phase 1 requirements (GRAPH-01 through GRAPH-06, DUAL-02, DUAL-03) are exercised by the integration test
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-graph-data-model/01-04-SUMMARY.md`
</output>

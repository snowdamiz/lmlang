---
phase: 01-core-graph-data-model
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - crates/lmlang-core/src/function.rs
  - crates/lmlang-core/src/module.rs
  - crates/lmlang-core/src/node.rs
  - crates/lmlang-core/src/lib.rs
autonomous: true
requirements:
  - GRAPH-04

must_haves:
  truths:
    - "FunctionDef includes typed parameters, return type, entry node, and capture list for closures"
    - "Closures are functions with non-empty captures list and is_closure=true"
    - "Modules form a tree with parent/child relationships and a root module"
    - "Visibility is pub/private on both functions and type definitions"
    - "Nested functions are supported via parent_function field on FunctionDef"
  artifacts:
    - path: "crates/lmlang-core/src/function.rs"
      provides: "FunctionDef, Capture, CaptureMode"
      contains: "struct FunctionDef"
    - path: "crates/lmlang-core/src/module.rs"
      provides: "ModuleDef, ModuleTree"
      contains: "struct ModuleDef"
  key_links:
    - from: "crates/lmlang-core/src/function.rs"
      to: "crates/lmlang-core/src/type_id.rs"
      via: "TypeId for parameter types and return type"
      pattern: "TypeId"
    - from: "crates/lmlang-core/src/function.rs"
      to: "crates/lmlang-core/src/id.rs"
      via: "FunctionId, ModuleId, NodeId for identity and ownership"
      pattern: "FunctionId|ModuleId|NodeId"
    - from: "crates/lmlang-core/src/module.rs"
      to: "crates/lmlang-core/src/id.rs"
      via: "ModuleId for tree structure"
      pattern: "ModuleId"
---

<objective>
Implement function definitions (with closures and nesting) and the hierarchical module tree.

Purpose: Functions and modules define how programs are organized. Functions provide typed interfaces (parameters, return types) and closure capture semantics. Modules provide hierarchical namespacing with visibility control. These are required by the ProgramGraph container (Plan 04) to represent program structure.

Output: FunctionDef with full closure support, ModuleDef with hierarchical tree, both integrated into lib.rs. Refactor the temporary ModuleDef stub from Plan 02's node.rs into the canonical module.rs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-graph-data-model/01-CONTEXT.md
@.planning/phases/01-core-graph-data-model/01-RESEARCH.md
@.planning/phases/01-core-graph-data-model/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement function definitions with closure support</name>
  <files>
    crates/lmlang-core/src/function.rs
  </files>
  <action>
**function.rs** -- Full function definition per RESEARCH.md Pattern 4 and Pattern 5:

`FunctionDef` struct:
- `id: FunctionId` -- unique identity
- `name: String` -- function name
- `module: ModuleId` -- which module owns this function
- `visibility: Visibility` -- pub/private per user decision (two-level)
- `params: Vec<(String, TypeId)>` -- named, typed parameters in order
- `return_type: TypeId` -- return type (use TypeId for Unit for void-like functions)
- `entry_node: Option<NodeId>` -- entry point in compute graph (None if function body not yet built). Use Option because functions may be declared before their body is constructed.
- `captures: Vec<Capture>` -- captured variables for closures (empty for non-closures)
- `is_closure: bool` -- true if this is a closure
- `parent_function: Option<FunctionId>` -- for nested functions/closures, the enclosing function. None for top-level functions.

`Capture` struct:
- `name: String` -- original variable name in enclosing scope
- `captured_type: TypeId` -- type of the captured value
- `mode: CaptureMode` -- how captured

`CaptureMode` enum: `ByValue, ByRef, ByMutRef`
- Derive `Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize`

All structs derive `Debug, Clone, Serialize, Deserialize`.

**Convenience methods on FunctionDef:**
- `new(id: FunctionId, name: String, module: ModuleId, params: Vec<(String, TypeId)>, return_type: TypeId) -> Self` -- creates a non-closure, top-level, public function with no captures and no entry node yet.
- `is_closure(&self) -> bool` -- returns self.is_closure
- `is_nested(&self) -> bool` -- returns self.parent_function.is_some()
- `closure(id: FunctionId, name: String, module: ModuleId, parent: FunctionId, params: Vec<(String, TypeId)>, return_type: TypeId, captures: Vec<Capture>) -> Self` -- creates a closure with is_closure=true and parent_function set.
- `arity(&self) -> usize` -- returns params.len()
- `capture_count(&self) -> usize` -- returns captures.len()

**Important doc comments:**
- On `FunctionDef`: "Functions are metadata -- the function body lives as compute nodes owned by this function's ID in the flat computational graph. See Pattern 4 in RESEARCH.md."
- On `captures`: "Closures are functions with non-empty captures. Inside the function body, CaptureAccess { index } nodes reference this list by position. At the call site, MakeClosure { function } takes captured values as data flow inputs."
- On `parent_function`: "Supports nesting per user decision. Inner functions can capture from enclosing scope. Nesting depth is unbounded."

Write unit tests:
- Test creating a regular (non-closure) function and verifying is_closure=false, is_nested=false, captures is empty.
- Test creating a closure with 2 captures and verifying is_closure=true, capture_count=2, parent is set.
- Test serde round-trip for FunctionDef with captures.
  </action>
  <verify>`cargo test` passes. FunctionDef has all fields from the specification.</verify>
  <done>FunctionDef supports regular functions, nested functions, and closures with typed capture lists. All required fields present: id, name, module, visibility, params, return_type, entry_node, captures, is_closure, parent_function.</done>
</task>

<task type="auto">
  <name>Task 2: Implement module tree and refactor ModuleDef</name>
  <files>
    crates/lmlang-core/src/module.rs
    crates/lmlang-core/src/node.rs
    crates/lmlang-core/src/lib.rs
  </files>
  <action>
**module.rs** -- Hierarchical module tree per RESEARCH.md Pattern 6 and user decision (Rust's mod system):

`ModuleDef` struct:
- `id: ModuleId` -- unique identity
- `name: String` -- module name
- `parent: Option<ModuleId>` -- None for root module
- `visibility: Visibility` -- pub/private

Derive `Debug, Clone, Serialize, Deserialize`.

`ModuleTree` struct -- manages the hierarchy:
- `modules: HashMap<ModuleId, ModuleDef>` -- all modules by ID
- `children: HashMap<ModuleId, Vec<ModuleId>>` -- parent -> children mapping
- `functions: HashMap<ModuleId, Vec<FunctionId>>` -- module -> functions mapping
- `type_defs: HashMap<ModuleId, Vec<TypeId>>` -- module -> type definitions mapping
- `root: ModuleId` -- the root module ID
- `next_id: u32` -- counter for generating ModuleId values

Methods on ModuleTree:
- `new(root_name: &str) -> Self` -- creates tree with a root module, returns the tree. Root module gets ModuleId(0).
- `root_id(&self) -> ModuleId` -- returns root module ID
- `add_module(&mut self, name: String, parent: ModuleId, visibility: Visibility) -> Result<ModuleId, CoreError>` -- creates child module under parent, returns new ID. Errors if parent not found.
- `get_module(&self, id: ModuleId) -> Option<&ModuleDef>` -- lookup by ID.
- `children(&self, id: ModuleId) -> &[ModuleId]` -- returns child module IDs (empty slice if none).
- `add_function(&mut self, module: ModuleId, function: FunctionId) -> Result<(), CoreError>` -- registers function in module. Errors if module not found.
- `add_type_def(&mut self, module: ModuleId, type_id: TypeId) -> Result<(), CoreError>` -- registers type def in module. Errors if module not found.
- `functions_in(&self, module: ModuleId) -> &[FunctionId]` -- returns functions in module.
- `path(&self, id: ModuleId) -> Vec<String>` -- returns full path from root (e.g., ["root", "math", "trig"]).

**node.rs refactor** -- Remove the temporary `ModuleDef` stub that Plan 02 created:
- Remove the inline `ModuleDef` definition from node.rs
- Replace with `use crate::module::ModuleDef;`
- Update `SemanticNode::Module(ModuleDef)` to use the imported type
- Also update `FunctionSummary` to use types from function.rs if helpful (or keep FunctionSummary as a lightweight version -- it should remain in node.rs since it's the semantic graph's view of a function, not the full definition)

**lib.rs** -- Add module declarations and re-exports:
```rust
pub mod function;
pub mod module;
```
Re-export: `FunctionDef, Capture, CaptureMode, ModuleDef, ModuleTree`.

Write unit tests:
- `module.rs`: Test creating a module tree with root -> child -> grandchild. Test path() returns correct path. Test add_function registers correctly. Test add_module to nonexistent parent returns error.
- `module.rs`: Test that root module has no parent (parent is None).
  </action>
  <verify>`cargo test` passes. `cargo build` compiles with no errors. The ModuleDef stub in node.rs is replaced with the real import from module.rs.</verify>
  <done>ModuleDef and ModuleTree provide hierarchical module organization with visibility. Functions and type defs are tracked per module. The temporary ModuleDef stub from Plan 02 is replaced with the canonical definition. Module paths can be computed from root.</done>
</task>

</tasks>

<verification>
- `cargo build` and `cargo test` pass
- FunctionDef has: id, name, module, visibility, params (typed), return_type, entry_node, captures, is_closure, parent_function
- Closures are represented as FunctionDef with non-empty captures and is_closure=true
- Nested functions use parent_function to reference enclosing function
- ModuleTree supports hierarchical nesting with parent/child relationships
- Visibility is Public/Private on both functions and modules (two-level per user decision)
- No duplicate ModuleDef -- single canonical definition in module.rs, imported everywhere
</verification>

<success_criteria>
- Functions support nesting and closures with typed capture lists (per user decision)
- Modules form a hierarchical tree (per user decision: Rust's mod system)
- Public/private visibility on functions and types (per user decision)
- ModuleTree can register functions and type defs per module
- All types serialize/deserialize correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-graph-data-model/01-03-SUMMARY.md`
</output>

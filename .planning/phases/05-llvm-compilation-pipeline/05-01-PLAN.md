---
phase: 05-llvm-compilation-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/lmlang-codegen/Cargo.toml
  - crates/lmlang-codegen/src/lib.rs
  - crates/lmlang-codegen/src/error.rs
  - crates/lmlang-codegen/src/types.rs
  - crates/lmlang-codegen/src/runtime.rs
  - crates/lmlang-codegen/src/linker.rs
  - .cargo/config.toml
autonomous: true
requirements: [EXEC-03, EXEC-04]

must_haves:
  truths:
    - "lmlang-codegen crate compiles with inkwell and LLVM 21 bindings"
    - "Every lmlang type (scalars, structs, arrays, enums, pointers, unit) maps to a valid LLVM type"
    - "Runtime error stubs (divide-by-zero, overflow, OOB) are declarable as LLVM external functions"
    - "Object files produced by LLVM can be linked into executables via system cc (static on Linux, minimal-system on macOS)"
  artifacts:
    - path: "crates/lmlang-codegen/Cargo.toml"
      provides: "Crate with inkwell llvm21-0 dependency"
      contains: "inkwell"
    - path: "crates/lmlang-codegen/src/lib.rs"
      provides: "Public API: CompileOptions, CompileResult, OptLevel"
    - path: "crates/lmlang-codegen/src/error.rs"
      provides: "CodegenError enum for all compilation failure modes"
    - path: "crates/lmlang-codegen/src/types.rs"
      provides: "lm_type_to_llvm mapping function"
    - path: "crates/lmlang-codegen/src/runtime.rs"
      provides: "declare_runtime_functions for error/print/IO stubs"
    - path: "crates/lmlang-codegen/src/linker.rs"
      provides: "link_executable via system cc"
  key_links:
    - from: "crates/lmlang-codegen/src/types.rs"
      to: "lmlang-core TypeId/TypeRegistry"
      via: "lm_type_to_llvm uses TypeRegistry to resolve compound types"
      pattern: "TypeRegistry"
    - from: "crates/lmlang-codegen/src/linker.rs"
      to: "system cc"
      via: "std::process::Command invocation"
      pattern: "Command::new.*cc"
---

<objective>
Create the lmlang-codegen crate with foundational modules: type mapping (lmlang types to LLVM IR types), error types, runtime function declarations, and system linker integration.

Purpose: Establishes the compilation infrastructure that all subsequent codegen plans build on. Without type mapping, runtime stubs, and linking, no op can be compiled.
Output: A compiling crate with type mapping, error handling, runtime declarations, and linking -- ready for per-function codegen in Plan 02.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-llvm-compilation-pipeline/05-RESEARCH.md
@.planning/phases/05-llvm-compilation-pipeline/05-CONTEXT.md
@crates/lmlang-core/src/types.rs
@crates/lmlang-core/src/type_id.rs
@crates/lmlang-core/src/ops.rs
@crates/lmlang-core/src/edge.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lmlang-codegen crate with types, error, and public API</name>
  <files>
    crates/lmlang-codegen/Cargo.toml
    crates/lmlang-codegen/src/lib.rs
    crates/lmlang-codegen/src/error.rs
    crates/lmlang-codegen/src/types.rs
  </files>
  <action>
Create the lmlang-codegen crate as a new workspace member.

**Cargo.toml:**
```toml
[dependencies]
inkwell = { version = "0.7.1", features = ["llvm21-0"] }
lmlang-core = { path = "../lmlang-core" }
lmlang-check = { path = "../lmlang-check" }
thiserror = "2"
tempfile = "3"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

Set `LLVM_SYS_210_PREFIX` in `.cargo/config.toml` at workspace root (create if not exists):
```toml
[env]
LLVM_SYS_210_PREFIX = "/opt/homebrew/opt/llvm"
```

**error.rs** -- CodegenError enum with variants:
- `TypeMapping(String)` -- unsupported or unresolvable type
- `UnsupportedOp(String)` -- op node not yet implemented
- `NoEntryFunction` -- no entry point found
- `InvalidGraph(String)` -- graph structure issues
- `LlvmError(String)` -- LLVM API failures (module verification, pass failures)
- `LinkerFailed(String)` -- cc subprocess failure
- `IoError(#[from] std::io::Error)` -- filesystem operations
- `TypeCheckFailed(Vec<lmlang_check::typecheck::TypeError>)` -- pre-codegen validation

Use `#[derive(Debug, thiserror::Error)]`.

**types.rs** -- Type mapping function:
```rust
pub fn lm_type_to_llvm<'ctx>(
    context: &'ctx Context,
    type_id: TypeId,
    registry: &TypeRegistry,
) -> Result<BasicTypeEnum<'ctx>, CodegenError>
```

Handle all type variants:
- `TypeId::BOOL` -> `context.bool_type().into()`
- `TypeId::I8` -> `context.i8_type().into()`
- `TypeId::I16` -> `context.i16_type().into()`
- `TypeId::I32` -> `context.i32_type().into()`
- `TypeId::I64` -> `context.i64_type().into()`
- `TypeId::F32` -> `context.f32_type().into()`
- `TypeId::F64` -> `context.f64_type().into()`
- `TypeId::UNIT` -> `context.struct_type(&[], false).into()` (empty struct for void-like)
- Array types: recursively map element type, create `elem.array_type(length)`
- Struct types: map all field types, create `context.struct_type(&fields, false)`
- Enum types: tagged union `{ i32 discriminant, [max_payload_bytes x i8] }` -- compute max payload size across all variants
- Pointer types: `context.ptr_type(AddressSpace::default())`
- Function types: map param types + return type, create fn_type -- return as pointer
- `TypeId::NEVER` -> error (should not appear in codegen)

Include unit tests for all scalar type mappings, array, struct, and enum type mappings.

**lib.rs** -- Public API types and module declarations:
- `pub mod error; pub mod types; pub mod runtime; pub mod linker;` (codegen module declared but created in Plan 02)
- `OptLevel` enum: O0, O1, O2, O3 (with serde Serialize/Deserialize)
- `CompileOptions` struct: `output_dir: PathBuf`, `opt_level: OptLevel` (default O0), `target_triple: Option<String>`, `debug_symbols: bool` (default false), `entry_function: Option<String>`
- `CompileResult` struct (with serde): `binary_path: PathBuf`, `target_triple: String`, `binary_size: u64`, `compilation_time_ms: u64`
- Default impl for CompileOptions: output_dir = `./build/`, opt_level = O0, target_triple = None (host), debug_symbols = false, entry_function = None
  </action>
  <verify>
`cargo check -p lmlang-codegen` compiles successfully. Run `cargo test -p lmlang-codegen` and all type mapping unit tests pass.
  </verify>
  <done>
lmlang-codegen crate exists, compiles with inkwell, type mapping covers all lmlang types, error enum covers all failure modes, public API types defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Runtime function declarations and system linker</name>
  <files>
    crates/lmlang-codegen/src/runtime.rs
    crates/lmlang-codegen/src/linker.rs
  </files>
  <action>
**runtime.rs** -- Declare external functions that compiled programs call at runtime:

```rust
pub fn declare_runtime_functions<'ctx>(context: &'ctx Context, module: &Module<'ctx>)
```

Declare these as external C functions in the LLVM module:
1. `lmlang_runtime_error(i32 error_kind, i32 node_id) -> void` -- abort with error message. Marked `noreturn`.
2. `printf(i8*, ...) -> i32` -- variadic C printf for Print op output
3. `exit(i32) -> void` -- process exit, marked `noreturn`
4. `fprintf(i8*, i8*, ...) -> i32` -- stderr output (for runtime error messages)

Per discretion: use direct libc calls (printf/fprintf/exit) rather than a separate runtime library. The `lmlang_runtime_error` function will be emitted as an LLVM function definition (not external) that calls fprintf(stderr, ...) + exit(code).

Implement `emit_runtime_error_fn`:
- Create the `lmlang_runtime_error` function body in LLVM IR
- Takes `(i32 error_kind, i32 node_id)` parameters
- Builds a switch on error_kind to select error message string
- Calls fprintf(stderr, "Runtime error [kind] at node %d\n", node_id)
- Calls exit(error_kind) -- maps error_kind directly to exit code
- Error kinds: 1=DivideByZero, 2=IntegerOverflow, 3=OutOfBounds, 4=NullPointer, 5=TypeMismatch

Also implement helper functions for emitting guards:
- `emit_div_guard<'ctx>(builder, context, module, function, divisor, node_id)` -- checks divisor != 0, branches to error on zero
- `emit_overflow_guard<'ctx>(builder, context, module, function, overflow_flag, node_id)` -- branches to error on overflow
- `emit_bounds_guard<'ctx>(builder, context, module, function, index, length, node_id)` -- checks 0 <= index < length

Also implement Print op support:
- `emit_print_value<'ctx>(builder, context, module, value, type_id)` -- emits printf call with appropriate format string based on type (i32->"%d\n", i64->"%ld\n", f64->"%f\n", bool->"true/false", etc.)

**linker.rs** -- Link object files to executables:

```rust
pub fn link_executable(
    obj_path: &Path,
    output_path: &Path,
    debug_symbols: bool,
) -> Result<(), CodegenError>
```

Implementation:
- Invoke `cc` via `std::process::Command`
- Pass object file path as input, `-o output_path`
- If `!debug_symbols`, pass `-Wl,-S` to strip debug symbols
- **Platform-specific linking per locked decision "static linking â€” self-contained, no runtime dependencies":**
  - **Linux:** pass `-static` flag for fully static linking (no runtime dependencies)
  - **macOS:** pass `-lSystem` for minimal system linkage. Note: macOS does not support fully static linking (`-static` is rejected by the Apple linker). `-lSystem` provides only the kernel syscall interface (libSystem.dylib), which is guaranteed present on all macOS installations and is the minimum possible dynamic dependency. This is the closest to "self-contained" achievable on macOS.
- Detect platform via `cfg!(target_os)` at compile time or `std::env::consts::OS` at runtime
- Capture stderr on failure, include in CodegenError::LinkerFailed
- Ensure output directory exists (create with `std::fs::create_dir_all`)

Include a unit test that creates a trivial `.o` file (if possible) or at least tests the command construction. Integration testing with real linking is deferred to Plan 04.
  </action>
  <verify>
`cargo check -p lmlang-codegen` compiles. `cargo test -p lmlang-codegen` passes. Runtime function declarations create valid LLVM IR (test by creating a Context, Module, calling declare_runtime_functions, and verifying module with `module.verify()`).
  </verify>
  <done>
Runtime error function emitted as LLVM IR, guard helpers (div, overflow, bounds) working, Print op support via printf, linker module invokes cc with correct flags.
  </done>
</task>

</tasks>

<verification>
- `cargo check -p lmlang-codegen` compiles without errors
- `cargo test -p lmlang-codegen` all tests pass
- Type mapping covers Bool, I8, I16, I32, I64, F32, F64, Unit, Array, Struct, Enum, Pointer
- Runtime module creates a verifiable LLVM module with runtime function declarations
- Linker module has the cc invocation logic ready
</verification>

<success_criteria>
- lmlang-codegen crate compiles with inkwell llvm21-0 feature
- All lmlang scalar + compound types map to valid LLVM types
- Runtime error declarations produce a valid LLVM module
- Guard helpers (div-by-zero, overflow, bounds check) emit correct branch-to-error patterns
- Linker can invoke system cc with the right flags
- `cargo test -p lmlang-codegen` passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-llvm-compilation-pipeline/05-01-SUMMARY.md`
</output>

---
phase: 07-multi-agent-concurrency
plan: 03
type: execute
wave: 3
depends_on:
  - "07-02"
files_modified:
  - crates/lmlang-server/src/handlers/mutations.rs
  - crates/lmlang-server/src/handlers/verify.rs
  - crates/lmlang-server/src/concurrency/verify.rs
  - crates/lmlang-server/src/concurrency/mod.rs
  - crates/lmlang-server/src/router.rs
  - crates/lmlang-server/tests/concurrency.rs
autonomous: true
requirements:
  - MAGENT-03
  - MAGENT-04

must_haves:
  truths:
    - "After agent mutations, incremental verification runs on modified functions and transitive dependents"
    - "Verification failure triggers auto-rollback, keeping the graph always in a verified state"
    - "Any agent can trigger full-graph verification via the verify endpoint"
    - "Two agents can register, acquire locks on different functions, and submit mutations concurrently without corruption"
    - "Hash mismatch on concurrent overlapping edits produces a 409 Conflict with structured details"
    - "Lock denial includes holder identity and description"
    - "Lock TTL expiry releases abandoned locks"
  artifacts:
    - path: "crates/lmlang-server/src/concurrency/verify.rs"
      provides: "find_verification_scope (build_call_graph + BFS dependents), validate_functions (scoped type check), run_incremental_verification"
      min_lines: 60
    - path: "crates/lmlang-server/tests/concurrency.rs"
      provides: "Integration tests proving MAGENT-01 through MAGENT-04"
      min_lines: 200
  key_links:
    - from: "crates/lmlang-server/src/concurrency/verify.rs"
      to: "lmlang-codegen::incremental::build_call_graph"
      via: "Call graph for transitive dependent discovery (Phase 6 dirty tracking)"
      pattern: "build_call_graph"
    - from: "crates/lmlang-server/src/concurrency/verify.rs"
      to: "lmlang-check::typecheck"
      via: "Per-node type checking on scoped functions (same logic as validate_graph, scoped to affected + dependents)"
      pattern: "TypeError|validate_functions"
    - from: "crates/lmlang-server/src/handlers/mutations.rs"
      to: "crates/lmlang-server/src/concurrency/verify.rs"
      via: "Post-mutation verification call"
      pattern: "run_incremental_verification"
    - from: "crates/lmlang-server/tests/concurrency.rs"
      to: "crates/lmlang-server/src/router.rs"
      via: "Integration tests against full router"
      pattern: "build_router"
---

<objective>
Add incremental verification on agent mutations (auto-rollback on failure) and comprehensive integration tests proving all four multi-agent concurrency requirements work end-to-end.

Purpose: Ensures the graph is always in a verified state after concurrent modifications (MAGENT-04) and provides confidence that the complete multi-agent system works correctly through integration testing of all requirements.
Output: Verification module, verification-integrated mutation handler, and integration test suite.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-agent-concurrency/07-CONTEXT.md
@.planning/phases/07-multi-agent-concurrency/07-RESEARCH.md
@.planning/phases/07-multi-agent-concurrency/07-01-SUMMARY.md
@.planning/phases/07-multi-agent-concurrency/07-02-SUMMARY.md
@crates/lmlang-server/src/handlers/mutations.rs
@crates/lmlang-server/src/handlers/verify.rs
@crates/lmlang-server/src/concurrency/mod.rs
@crates/lmlang-server/src/service.rs
@crates/lmlang-codegen/src/incremental.rs
@crates/lmlang-storage/src/hash.rs
@crates/lmlang-check/src/typecheck/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add incremental verification on agent mutations with auto-rollback</name>
  <files>
    crates/lmlang-server/src/concurrency/verify.rs
    crates/lmlang-server/src/concurrency/mod.rs
    crates/lmlang-server/src/handlers/mutations.rs
    crates/lmlang-server/src/handlers/verify.rs
    crates/lmlang-server/src/router.rs
  </files>
  <action>
    **Create `concurrency/verify.rs`:**

    Implements truly incremental verification per the locked CONTEXT.md decision: "only modified functions + transitive dependents are checked (leverages Phase 6 dirty tracking)."

    `find_verification_scope(graph: &ProgramGraph, affected_functions: &[FunctionId]) -> Vec<FunctionId>`:
    - Call `lmlang_codegen::incremental::build_call_graph(graph)` to get the caller->callee map.
    - Build a reverse call graph (callee -> callers) from it.
    - BFS from each function in `affected_functions` through the reverse graph to collect all transitive dependents (callers, callers-of-callers, etc.).
    - Return the union of `affected_functions` + all transitive dependents. This is the verification scope.

    `validate_functions(graph: &ProgramGraph, scope: &[FunctionId]) -> Vec<TypeError>`:
    - For each function in `scope`, iterate over its compute nodes via `graph.function_nodes(func_id)`.
    - For each compute node, run the same per-node type checking logic that `validate_graph` uses (check incoming data edges against op type rules, verify input counts).
    - Collect and return all `TypeError`s found.
    - This is a scoped version of `validate_graph` that only checks nodes within the specified functions rather than the entire graph.

    `run_incremental_verification(graph: &ProgramGraph, affected_functions: &[FunctionId]) -> VerifyResponse`:
    - Call `find_verification_scope(graph, affected_functions)` to get the full scope.
    - Call `validate_functions(graph, &scope)` to check only those functions.
    - Convert TypeErrors to DiagnosticErrors.
    - Return `VerifyResponse { valid, errors, warnings }`.

    **Update `concurrency/mod.rs`:** Add `pub mod verify;`.

    **Integrate verification into `handlers/mutations.rs`:**

    In the agent-aware mutation path (Mode B from Plan 02), after `service.propose_edit()` returns with `committed: true`:
    1. Call `run_incremental_verification(service.graph(), &affected_functions)`.
    2. If verification fails (valid == false):
       a. Call `service.undo()` to auto-rollback the mutation.
       b. Return a ProposeEditResponse with `valid: false`, `committed: false`, and the verification errors.
    3. If verification passes, return the normal success response.

    This ensures the graph is always in a verified state per CONTEXT.md ("synchronous verification: agent holds lock until verification passes").

    **Extend verify handler for global verification:**
    The existing `POST /programs/{id}/verify` endpoint already supports `VerifyScope::Full`. Ensure it remains accessible without agent identity (any agent can trigger full verification as a safety net per CONTEXT.md). No changes needed if it already works -- just verify it compiles with the RwLock changes from Plan 01.
  </action>
  <verify>
    `cargo check --package lmlang-server` compiles. `cargo test --package lmlang-server` passes all existing tests.
  </verify>
  <done>
    Post-mutation incremental verification runs after every agent mutation. Verification failure triggers auto-rollback via undo. Global verification endpoint accessible to any agent. Graph is always in a verified state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests proving all four multi-agent requirements</name>
  <files>
    crates/lmlang-server/tests/concurrency.rs
  </files>
  <action>
    Create a new integration test file `crates/lmlang-server/tests/concurrency.rs` using the same pattern as existing tests (tower::ServiceExt::oneshot on the Router, no network server).

    **Test helper:** Create `test_app() -> Router` that builds an AppState::in_memory() and build_router(state). Create `post_json`, `get_json`, `delete_json` helpers matching existing test helpers.

    **Test helper:** `register_agent(router, name) -> (Uuid, Router)` -- registers an agent and returns the agent_id.

    **Test helper:** `build_two_function_program(router, agent_id) -> (i64, u32, u32)` -- creates a program with two functions (each with a Const+Return node pair and edges), returns (program_id, func_id_1, func_id_2). Uses batch mutations.

    **Tests to implement:**

    1. **`test_agent_registration_and_listing`** (MAGENT-01):
       - Register two agents with names "Agent A" and "Agent B".
       - GET /agents returns both.
       - DELETE /agents/{id} for agent A.
       - GET /agents returns only agent B.

    2. **`test_concurrent_reads_different_functions`** (MAGENT-01):
       - Register two agents.
       - Build a program with two functions.
       - Both agents acquire read locks on their respective functions.
       - Both agents can query the program overview and function context concurrently.
       - Both agents release their locks.

    3. **`test_write_lock_prevents_concurrent_modification`** (MAGENT-02):
       - Register two agents.
       - Build a program with two functions.
       - Agent A acquires write lock on function 1.
       - Agent B attempts to acquire write lock on function 1 -- gets LockDenied with holder info (agent A's name).
       - Agent A releases lock.
       - Agent B successfully acquires write lock on function 1.

    4. **`test_batch_lock_acquisition_all_or_nothing`** (MAGENT-02):
       - Register two agents.
       - Build a program with three functions.
       - Agent A acquires write lock on function 2.
       - Agent B attempts batch acquire on functions 1, 2, 3 -- fails because function 2 is held.
       - Verify function 1 and 3 are NOT locked by agent B (all-or-nothing rollback).
       - Agent A releases function 2.
       - Agent B successfully batch acquires all three.

    5. **`test_conflict_detection_on_hash_mismatch`** (MAGENT-03):
       - Register two agents.
       - Build a program with one function containing a Const node.
       - Agent A acquires write lock, reads function hash (via GET function endpoint or compute manually).
       - Agent A modifies the function (add a node) and commits.
       - Agent A releases write lock.
       - Agent B acquires write lock on same function.
       - Agent B submits mutation with the OLD hash as expected_hash.
       - Server detects hash mismatch and returns 409 Conflict with ConflictDetail.

    6. **`test_non_agent_mutations_backward_compatible`** (MAGENT-01):
       - Without registering any agent (no X-Agent-Id header), submit mutations.
       - Mutations succeed as before -- no lock required, no conflict detection.
       - Verifies backward compatibility.

    7. **`test_verification_after_mutation`** (MAGENT-04):
       - Register an agent.
       - Build a program with a function.
       - Agent acquires write lock on the function.
       - Agent submits a mutation that creates a type error (e.g., add a BinaryArith node with incorrect edge types).
       - Verification catches the error, auto-rollback occurs.
       - Response shows valid=false, committed=false, with type errors.
       - Graph remains in the pre-mutation (valid) state.

    8. **`test_lock_status_endpoint`** (MAGENT-02):
       - Register two agents.
       - Build a program.
       - Agent A acquires write lock on function 1 with description "editing auth".
       - Agent B acquires read lock on function 2.
       - GET /programs/{id}/locks shows both locks with correct holders and descriptions.

    9. **`test_global_write_lock_for_structure_changes`** (MAGENT-02):
       - Register an agent.
       - Build a program.
       - Agent submits AddFunction mutation -- should succeed (global write lock acquired automatically).
       - Verify the new function exists in the program.

    10. **`test_deregister_releases_all_locks`** (MAGENT-02):
        - Register an agent.
        - Build a program.
        - Agent acquires write locks on two functions.
        - DELETE /agents/{id} deregisters the agent.
        - GET /programs/{id}/locks shows no locks held.

    Each test should use `#[tokio::test]` and the tower::ServiceExt::oneshot pattern from existing tests.
  </action>
  <verify>
    `cargo test --package lmlang-server` passes ALL tests (existing + new concurrency tests). Specifically `cargo test --package lmlang-server concurrency` runs all 10 new tests.
  </verify>
  <done>
    10 integration tests prove all four MAGENT requirements: concurrent read/write access (01), region locking with lock denial and batch semantics (02), hash-based conflict detection with structured rejection (03), and verification on mutation with auto-rollback (04). All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --package lmlang-server` succeeds
2. `cargo test --package lmlang-server` passes all tests (existing + new)
3. All 10 concurrency integration tests pass
4. Verification auto-rollback test proves graph stays valid after rejected mutations
5. Conflict detection test proves hash mismatch returns 409 with details
6. Backward compatibility test proves non-agent usage is unaffected
</verification>

<success_criteria>
- Incremental verification runs after every agent mutation
- Verification failure auto-rolls back the mutation (graph always verified)
- 10 integration tests cover all 4 MAGENT requirements
- All tests pass (existing + new)
- Non-agent mutations remain backward compatible
- Lock denial includes holder identity and description
- Batch lock acquisition is all-or-nothing
- Agent deregistration releases all held locks
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-agent-concurrency/07-03-SUMMARY.md`
</output>

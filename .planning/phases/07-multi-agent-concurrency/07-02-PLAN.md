---
phase: 07-multi-agent-concurrency
plan: 02
type: execute
wave: 2
depends_on:
  - "07-01"
files_modified:
  - crates/lmlang-server/src/handlers/mod.rs
  - crates/lmlang-server/src/handlers/agents.rs
  - crates/lmlang-server/src/handlers/locks.rs
  - crates/lmlang-server/src/handlers/mutations.rs
  - crates/lmlang-server/src/router.rs
  - crates/lmlang-server/src/schema/mutations.rs
  - crates/lmlang-server/src/concurrency/mod.rs
autonomous: true
requirements:
  - MAGENT-01
  - MAGENT-02
  - MAGENT-03

must_haves:
  truths:
    - "Agents register via POST /agents/register and receive a UUID session ID"
    - "Agents acquire/release function locks via HTTP endpoints"
    - "Lock status endpoint shows all current locks, holders, and descriptions"
    - "Mutations with X-Agent-Id and expected_hashes trigger hash-based conflict detection"
    - "Conflict rejection includes structured diff showing what changed"
    - "Module structure mutations (AddFunction, AddModule) acquire global write lock automatically"
    - "Non-agent mutations continue to work (backward compatibility)"
  artifacts:
    - path: "crates/lmlang-server/src/handlers/agents.rs"
      provides: "register_agent, deregister_agent, list_agents handlers"
      min_lines: 40
    - path: "crates/lmlang-server/src/handlers/locks.rs"
      provides: "acquire_locks, release_locks, lock_status handlers"
      min_lines: 80
    - path: "crates/lmlang-server/src/router.rs"
      provides: "Routes for /agents/*, /programs/{id}/locks/*"
      contains: "agents"
  key_links:
    - from: "crates/lmlang-server/src/handlers/locks.rs"
      to: "crates/lmlang-server/src/concurrency/lock_manager.rs"
      via: "LockManager acquire/release calls"
      pattern: "lock_manager"
    - from: "crates/lmlang-server/src/handlers/mutations.rs"
      to: "crates/lmlang-server/src/concurrency/conflict.rs"
      via: "Hash-based conflict check before applying mutations"
      pattern: "check_hashes|expected_hashes"
    - from: "crates/lmlang-server/src/handlers/agents.rs"
      to: "crates/lmlang-server/src/concurrency/agent.rs"
      via: "AgentRegistry register/deregister/list"
      pattern: "agent_registry"
---

<objective>
Wire the concurrency infrastructure into HTTP endpoints and refactor the mutation handler for agent-aware conflict detection. Add agent registration, lock management, and lock status endpoints. Make mutations optionally agent-aware with expected hash validation.

Purpose: Makes the concurrency system accessible to AI agents through the existing HTTP/JSON API, completing the agent-visible surface of multi-agent support.
Output: New HTTP endpoints for agent/lock management, mutation handler with optional conflict detection, router with all new routes.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-multi-agent-concurrency/07-CONTEXT.md
@.planning/phases/07-multi-agent-concurrency/07-RESEARCH.md
@.planning/phases/07-multi-agent-concurrency/07-01-SUMMARY.md
@crates/lmlang-server/src/router.rs
@crates/lmlang-server/src/handlers/mod.rs
@crates/lmlang-server/src/handlers/mutations.rs
@crates/lmlang-server/src/schema/mutations.rs
@crates/lmlang-server/src/state.rs
@crates/lmlang-server/src/concurrency/mod.rs
@crates/lmlang-server/src/concurrency/lock_manager.rs
@crates/lmlang-server/src/concurrency/agent.rs
@crates/lmlang-server/src/concurrency/conflict.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent and lock HTTP handlers with router wiring</name>
  <files>
    crates/lmlang-server/src/handlers/mod.rs
    crates/lmlang-server/src/handlers/agents.rs
    crates/lmlang-server/src/handlers/locks.rs
    crates/lmlang-server/src/router.rs
  </files>
  <action>
    **Create `handlers/agents.rs`** with thin handlers following existing pattern (extract -> call -> respond):

    1. `register_agent`: `POST /agents/register`. Accepts `Json<RegisterAgentRequest>`. Calls `state.agent_registry.register(req.name)`. Returns `Json<RegisterAgentResponse>` with agent_id UUID and registered_at timestamp.

    2. `deregister_agent`: `DELETE /agents/{agent_id}`. Parses agent_id from path as UUID. Calls `state.agent_registry.deregister(&agent_id)`. Also calls `state.lock_manager.release_all(&agent_id)` to release all locks held by this agent. Returns 200 on success, 404 if agent not found.

    3. `list_agents`: `GET /agents`. Calls `state.agent_registry.list()`. Returns `Json<ListAgentsResponse>` with all active agents.

    **Create `handlers/locks.rs`** with lock management handlers:

    1. `acquire_locks`: `POST /programs/{id}/locks/acquire`. Requires X-Agent-Id header (extract via `extract_agent_id`). Accepts `Json<AcquireLockRequest>` with `function_ids: Vec<u32>`, `mode: String`, `description: Option<String>`. Convert u32 to FunctionId. If mode is "write" and multiple functions, use `lock_manager.batch_acquire_write()`. If mode is "read", acquire read locks individually. Returns `Json<AcquireLockResponse>` with grants or `ApiError::LockDenied` with holder info.

    2. `release_locks`: `POST /programs/{id}/locks/release`. Requires X-Agent-Id header. Accepts `Json<ReleaseLockRequest>` with `function_ids: Vec<u32>`. Calls `lock_manager.release()` for each. Returns `Json<ReleaseLockResponse>` with list of released function IDs.

    3. `lock_status`: `GET /programs/{id}/locks`. No agent ID required (any agent can query). Calls `lock_manager.status()`. Returns `Json<LockStatusResponse>` with all current locks, holders, descriptions, and expiry times.

    **Update `handlers/mod.rs`:** Add `pub mod agents;` and `pub mod locks;`.

    **Update `router.rs`:** Add new routes:
    ```rust
    // Agent management
    .route("/agents/register", post(handlers::agents::register_agent))
    .route("/agents/{agent_id}", delete(handlers::agents::deregister_agent))
    .route("/agents", get(handlers::agents::list_agents))
    // Lock management
    .route("/programs/{id}/locks/acquire", post(handlers::locks::acquire_locks))
    .route("/programs/{id}/locks/release", post(handlers::locks::release_locks))
    .route("/programs/{id}/locks", get(handlers::locks::lock_status))
    ```
  </action>
  <verify>
    `cargo check --package lmlang-server` compiles. All new routes are wired in the router. Existing routes unchanged.
  </verify>
  <done>
    Agent registration (POST/DELETE/GET) and lock management (acquire/release/status) endpoints exist and compile. Router has all 6 new routes plus existing routes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make mutations agent-aware with conflict detection and global write lock</name>
  <files>
    crates/lmlang-server/src/handlers/mutations.rs
    crates/lmlang-server/src/schema/mutations.rs
    crates/lmlang-server/src/concurrency/mod.rs
  </files>
  <action>
    **Extend `schema/mutations.rs`:**
    Add an optional `expected_hashes` field to `ProposeEditRequest`:
    ```rust
    /// Per-function blake3 hex hashes from the agent's last read.
    /// When present with X-Agent-Id header, enables conflict detection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_hashes: Option<HashMap<u32, String>>,
    ```
    This is optional so that non-agent (single-agent) requests continue to work without any changes.

    **Refactor `handlers/mutations.rs` `propose_edit` handler:**

    The handler should now support two modes:

    **Mode A: Non-agent (backward compatible).** If no X-Agent-Id header is present, behave exactly as before: acquire service write lock, call service.propose_edit(), done. No conflict detection, no function lock verification.

    **Mode B: Agent-aware (new).** If X-Agent-Id header is present:
    1. Extract agent_id via `extract_agent_id(&headers)`.
    2. Determine affected functions from mutations. For InsertNode/RemoveNode/ModifyNode/AddEdge/AddControlEdge/RemoveEdge, the affected function is the owner of the node(s). For AddFunction/AddModule, these are module structure changes.
    3. For module structure mutations (AddFunction, AddModule): acquire the global write lock from LockManager (`state.lock_manager.global_write_lock.write().await`). This serializes all module structure changes per CONTEXT.md.
    4. For non-structure mutations: verify the agent holds write locks on all affected functions via `state.lock_manager.verify_write_locks()`. Return LockRequired error if not.
    5. If `expected_hashes` is provided, call `conflict::check_hashes(service.graph(), &expected_hashes)`. On conflict, return 409 Conflict with ConflictDetail including the function diff. This implements reject-and-retry per discretion recommendation.
    6. Apply mutations via `service.propose_edit(req)`.
    7. Return response as before.

    **Add helper function `affected_functions(mutations: &[Mutation], graph: &ProgramGraph) -> (Vec<FunctionId>, bool)` in `concurrency/mod.rs`:**
    - Returns (list of affected function IDs, is_structure_change).
    - InsertNode: owner from the mutation.
    - RemoveNode/ModifyNode: look up node in graph to get owner.
    - AddEdge/AddControlEdge/RemoveEdge: look up from/to nodes to get owners.
    - AddFunction/AddModule: sets is_structure_change = true.
    - Dedup the function ID list.

    **Important design note:** The `propose_edit` handler signature gains `headers: HeaderMap` parameter for X-Agent-Id extraction. The Path and Json extractors remain the same. The handler flow is:
    ```
    1. Parse request + optional agent_id from headers
    2. If agent_id present:
       a. Determine affected functions + is_structure_change
       b. If structure change: acquire global write lock guard
       c. If not structure: verify agent holds write locks
       d. If expected_hashes: check for conflicts
    3. Acquire service write lock
    4. Call service.propose_edit()
    5. Return response (drop all guards)
    ```
  </action>
  <verify>
    `cargo check --package lmlang-server` compiles. `cargo test --package lmlang-server` passes all existing tests (backward compatibility: non-agent mutations work as before).
  </verify>
  <done>
    Mutation handler supports both agent-aware (with conflict detection, lock verification, global write lock for structure changes) and non-agent (backward compatible) modes. ProposeEditRequest has optional expected_hashes field. affected_functions helper determines which functions a set of mutations touches.
  </done>
</task>

</tasks>

<verification>
1. `cargo check --package lmlang-server` succeeds
2. `cargo test --package lmlang-server` passes all existing tests
3. All 6 new endpoints compile and are wired in the router
4. Mutations without X-Agent-Id header work exactly as before
5. Agent agent registration, lock acquire/release, and lock status routes exist
</verification>

<success_criteria>
- POST /agents/register, DELETE /agents/{id}, GET /agents endpoints exist
- POST /programs/{id}/locks/acquire, POST /programs/{id}/locks/release, GET /programs/{id}/locks endpoints exist
- Mutations with X-Agent-Id + expected_hashes perform hash-based conflict detection
- Module structure mutations (AddFunction, AddModule) automatically acquire global write lock
- Non-agent mutations work unchanged (backward compatible)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-multi-agent-concurrency/07-02-SUMMARY.md`
</output>

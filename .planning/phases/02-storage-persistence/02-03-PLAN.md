---
phase: 02-storage-persistence
plan: 03
type: tdd
wave: 2
depends_on:
  - 02-01
files_modified:
  - crates/lmlang-storage/Cargo.toml
  - crates/lmlang-storage/src/lib.rs
  - crates/lmlang-storage/src/hash.rs
autonomous: true
requirements:
  - STORE-04

must_haves:
  truths:
    - "Every graph node has a deterministic content hash that changes when and only when the node's content changes"
    - "Content hashes compose upward in Merkle-tree style: a node's hash includes its own content plus sorted edge target hashes"
    - "Per-function root hashes enable detecting cross-function changes by comparing function roots"
    - "Hashes are computed from stored content (not stored in database) and are always consistent via eager recomputation"
  artifacts:
    - path: "crates/lmlang-storage/src/hash.rs"
      provides: "Content hashing with blake3 and Merkle-tree composition"
      min_lines: 80
  key_links:
    - from: "crates/lmlang-storage/src/hash.rs"
      to: "crates/lmlang-core"
      via: "hashes ComputeNode, FlowEdge, and ProgramGraph contents"
      pattern: "ComputeNode|FlowEdge|ProgramGraph"
---

<objective>
Implement deterministic content hashing for graph nodes using blake3 with Merkle-tree composition from leaf nodes through edges to per-function root hashes.

Purpose: Delivers STORE-04 -- every graph node has a deterministic content hash for identity and change detection. Merkle-tree style composition (per user decision) mirrors git's content-addressable model, enabling structural integrity verification by comparing root hashes. Hashes are derived state, never stored in the database.

Output: hash.rs module with node hashing, Merkle-tree composition, and per-function root hash computation.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-storage-persistence/02-RESEARCH.md
@.planning/phases/02-storage-persistence/02-CONTEXT.md
@.planning/phases/02-storage-persistence/02-01-SUMMARY.md
@crates/lmlang-core/src/node.rs
@crates/lmlang-core/src/edge.rs
@crates/lmlang-core/src/ops.rs
@crates/lmlang-core/src/graph.rs
@crates/lmlang-core/src/id.rs
</context>

<feature>
  <name>Deterministic Content Hashing</name>
  <files>
    crates/lmlang-storage/Cargo.toml
    crates/lmlang-storage/src/lib.rs
    crates/lmlang-storage/src/hash.rs
  </files>
  <behavior>
    Content hashing provides deterministic identity for graph nodes and functions.

    **Level 1 - Node content hash:**
    - Given a ComputeNode, produce a blake3 hash of its content (op + owner)
    - Deterministic: same node content always produces the same hash
    - Different: changing any field (op variant, owner) produces a different hash
    - Uses serde_json canonical serialization (all hashable types use Vec/IndexMap, no HashMap)

    **Level 2 - Node hash with edges (Merkle composition):**
    - Given a node and its outgoing edges with target node hashes, produce a composite hash
    - Hash includes: node content hash + sorted edge data + target node hashes
    - Edges sorted by (target_port/branch_index, target_node_id) for deterministic ordering
    - Adding, removing, or modifying an edge changes the composite hash
    - Changing a target node's content changes this node's composite hash (Merkle propagation)

    **Level 3 - Per-function root hash:**
    - Given a ProgramGraph and FunctionId, compute the function's root hash
    - Includes all nodes owned by the function, composed in topological order
    - Changing any node or edge within the function changes the function root hash
    - Different functions with identical structure but different node content produce different hashes
    - Cross-function change detection: compare function root hashes

    Cases:
    - hash_node_content(ComputeNode{Add, FunctionId(0)}) -> deterministic 32-byte hash
    - hash_node_content(ComputeNode{Add, FunctionId(0)}) == hash_node_content(same node) (deterministic)
    - hash_node_content(ComputeNode{Add, FunctionId(0)}) != hash_node_content(ComputeNode{Sub, FunctionId(0)}) (op change)
    - hash_node_content(ComputeNode{Add, FunctionId(0)}) != hash_node_content(ComputeNode{Add, FunctionId(1)}) (owner change)
    - hash_function(graph, fn_id) changes when a node in the function changes
    - hash_function(graph, fn_id) does NOT change when a node in a different function changes
    - hash_function(graph, fn_id) changes when an edge within the function is added/removed
  </behavior>
  <implementation>
1. Add `blake3 = "1.8"` to `crates/lmlang-storage/Cargo.toml` dependencies.

2. Create `crates/lmlang-storage/src/hash.rs` with these public functions:

   `pub fn hash_node_content(node: &ComputeNode) -> blake3::Hash`
   - Create blake3::Hasher
   - Serialize node.op with serde_json::to_vec (deterministic since ComputeNodeOp uses no HashMap)
   - Update hasher with op bytes
   - Update hasher with node.owner.0.to_le_bytes()
   - Finalize and return

   `pub fn hash_node_with_edges(node: &ComputeNode, outgoing: &[(NodeId, FlowEdge, blake3::Hash)]) -> blake3::Hash`
   - Create hasher, update with hash_node_content(node).as_bytes()
   - Sort outgoing by a deterministic key: for Data edges sort by (target_port, target_node_id.0), for Control edges sort by (branch_index.unwrap_or(u16::MAX), target_node_id.0). Use an enum discriminant to separate Data from Control in sort order.
   - For each sorted edge: serialize edge with serde_json::to_vec, update hasher with edge bytes + target hash bytes
   - Finalize and return

   `pub fn hash_function(graph: &ProgramGraph, func_id: FunctionId) -> blake3::Hash`
   - Get all nodes owned by this function via graph.function_nodes(func_id)
   - For each node, collect its outgoing edges from graph.compute() (filter to edges whose source is this node)
   - Build a HashMap<NodeId, blake3::Hash> for all node content hashes
   - Process nodes in a deterministic order: sort by NodeId ascending
   - For each node (sorted), compute hash_node_with_edges using already-computed target hashes
     - Note: for true Merkle-tree composition, we'd need topological order. But since we're computing ALL node hashes and the function is a DAG for data flow, we can do two passes: first compute all content hashes, then compute all composite hashes. For cycles (control flow back-edges), use the content hash only for the back-edge target.
   - Combine all node composite hashes into a single function hash:
     - Create a final hasher
     - Sort node hashes by NodeId
     - Update with each (NodeId bytes + composite hash bytes)
     - Finalize as the function root hash

   `pub fn hash_all_functions(graph: &ProgramGraph) -> HashMap<FunctionId, blake3::Hash>`
   - Iterate graph.functions() keys in sorted FunctionId order (per Pitfall 2: never iterate HashMap directly for hashing)
   - Call hash_function for each
   - Return map

3. Add `pub mod hash;` to lib.rs and re-export key functions.

4. Write tests following RED-GREEN-REFACTOR:

   RED tests (write first, must fail):
   - `test_node_content_hash_deterministic`: same node produces same hash twice
   - `test_node_content_hash_changes_on_op_change`: Add vs Sub produces different hash
   - `test_node_content_hash_changes_on_owner_change`: FunctionId(0) vs FunctionId(1)
   - `test_node_with_edges_changes_on_edge_add`: hash with 0 edges != hash with 1 edge
   - `test_node_with_edges_changes_on_target_hash_change`: same edges but different target hashes
   - `test_function_hash_deterministic`: same graph produces same function hash
   - `test_function_hash_changes_on_node_mutation`: add a node to function, hash changes
   - `test_function_hash_independent_across_functions`: modifying function B does not change function A's hash
   - `test_function_hash_changes_on_edge_add`: adding an edge within the function changes the hash

   GREEN: implement hash functions to pass all tests.

   REFACTOR: clean up if needed, ensure all tests still pass.
  </implementation>
</feature>

<verification>
1. `cargo test -p lmlang-storage` passes all hash tests
2. Determinism verified: same input always produces same hash
3. Sensitivity verified: any content change produces a different hash
4. Function isolation verified: changing one function does not affect another function's hash
5. Merkle composition verified: changing a target node changes its parent's composite hash
</verification>

<success_criteria>
- blake3 content hashing produces deterministic, collision-resistant hashes for graph nodes
- Merkle-tree composition propagates changes upward from target nodes through edges
- Per-function root hashes enable O(1) change detection across functions
- Hash computation is eager and always consistent (per user decision)
- No HashMap iteration order issues (all sorts are by deterministic keys)
</success_criteria>

<output>
After completion, create `.planning/phases/02-storage-persistence/02-03-SUMMARY.md`
</output>

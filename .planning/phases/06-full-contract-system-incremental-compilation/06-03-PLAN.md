---
phase: 06-full-contract-system-incremental-compilation
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - crates/lmlang-codegen/Cargo.toml
  - crates/lmlang-codegen/src/incremental.rs
  - crates/lmlang-codegen/src/lib.rs
  - crates/lmlang-codegen/src/compiler.rs
  - crates/lmlang-codegen/src/codegen.rs
  - crates/lmlang-storage/src/hash.rs
  - crates/lmlang-server/src/schema/compile.rs
  - crates/lmlang-server/src/handlers/compile.rs
  - crates/lmlang-server/src/service.rs
autonomous: true
requirements:
  - STORE-05

must_haves:
  truths:
    - "After editing a single function in a multi-function program, only that function and its dependents recompile"
    - "Agent can query which functions are dirty before triggering compilation"
    - "Agent can see a recompilation plan showing dirty functions, dirty dependents, and cached functions"
    - "Contract changes do NOT mark functions dirty for recompilation"
    - "Full recompilation is the fallback for first builds or when cache is cleared"
  artifacts:
    - path: "crates/lmlang-codegen/src/incremental.rs"
      provides: "IncrementalState, RecompilationPlan, call graph construction, dirty computation"
      exports: ["IncrementalState", "RecompilationPlan", "build_call_graph"]
    - path: "crates/lmlang-server/src/schema/compile.rs"
      provides: "DirtyStatusResponse, DirtyFunctionView for agent dirty queries"
      contains: "DirtyStatusResponse"
    - path: "crates/lmlang-codegen/src/compiler.rs"
      provides: "Incremental compilation path in compile() alongside existing full compilation"
      contains: "IncrementalState"
  key_links:
    - from: "crates/lmlang-codegen/src/compiler.rs"
      to: "crates/lmlang-codegen/src/incremental.rs"
      via: "compile() checks dirty state and routes to incremental or full path"
      pattern: "IncrementalState|compute_dirty|RecompilationPlan"
    - from: "crates/lmlang-codegen/src/incremental.rs"
      to: "crates/lmlang-storage/src/hash.rs"
      via: "Uses hash_function_for_compilation for dirty detection"
      pattern: "hash_function_for_compilation|hash_all_functions_for_compilation"
    - from: "crates/lmlang-server/src/handlers/compile.rs"
      to: "crates/lmlang-server/src/service.rs"
      via: "Dirty query endpoint calls service method"
      pattern: "dirty_status|DirtyStatusResponse"
---

<objective>
Implement incremental recompilation with function-level dirty tracking, per-function object file caching, call graph analysis for dependent identification, and agent-visible dirty status queries.

Purpose: After editing a single function in a multi-function program, only that function and its dependents recompile. The agent has full visibility into dirty state and can query the recompilation plan before triggering a build. This dramatically reduces compilation time for large programs.

Output: IncrementalState engine in lmlang-codegen, per-function object file compilation, dirty query API endpoint, and incremental compilation path in the compiler.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-full-contract-system-incremental-compilation/06-RESEARCH.md
@.planning/phases/06-full-contract-system-incremental-compilation/06-01-SUMMARY.md

@crates/lmlang-codegen/src/compiler.rs
@crates/lmlang-codegen/src/codegen.rs
@crates/lmlang-codegen/src/linker.rs
@crates/lmlang-codegen/src/lib.rs
@crates/lmlang-codegen/Cargo.toml
@crates/lmlang-storage/src/hash.rs
@crates/lmlang-server/src/schema/compile.rs
@crates/lmlang-server/src/handlers/compile.rs
@crates/lmlang-server/src/service.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Incremental compilation engine with dirty tracking and per-function object files</name>
  <files>
    crates/lmlang-codegen/Cargo.toml
    crates/lmlang-codegen/src/incremental.rs
    crates/lmlang-codegen/src/lib.rs
    crates/lmlang-codegen/src/compiler.rs
    crates/lmlang-codegen/src/codegen.rs
  </files>
  <action>
    **1. Add blake3 dependency (crates/lmlang-codegen/Cargo.toml):**

    Add to `[dependencies]`:
    ```toml
    blake3 = "1.8"
    lmlang-storage = { path = "../lmlang-storage" }
    ```

    lmlang-storage is needed for `hash_function_for_compilation` and `hash_all_functions_for_compilation`.

    **2. Create incremental compilation module (crates/lmlang-codegen/src/incremental.rs):**

    Define types:

    ```rust
    use std::collections::{HashMap, HashSet, VecDeque};
    use std::path::{Path, PathBuf};
    use serde::{Serialize, Deserialize};
    use lmlang_core::id::FunctionId;
    use lmlang_core::graph::ProgramGraph;
    use lmlang_core::ops::{ComputeNodeOp, ComputeOp};

    /// Tracks compilation state for incremental builds.
    #[derive(Debug, Serialize, Deserialize)]
    pub struct IncrementalState {
        /// Per-function hash from last successful compilation.
        last_compiled_hashes: HashMap<FunctionId, [u8; 32]>,
        /// Compilation settings hash (opt level, target triple) to detect settings changes.
        settings_hash: [u8; 32],
        /// Directory containing cached per-function object files.
        cache_dir: PathBuf,
    }

    /// A recompilation plan computed from dirty analysis.
    #[derive(Debug, Clone, Serialize)]
    pub struct RecompilationPlan {
        /// Functions that changed directly.
        pub dirty: Vec<FunctionId>,
        /// Functions dirty because a callee changed.
        pub dirty_dependents: Vec<FunctionId>,
        /// Functions that can use cached object files.
        pub cached: Vec<FunctionId>,
        /// Whether any recompilation is needed.
        pub needs_recompilation: bool,
    }
    ```

    Implement `IncrementalState`:

    - `new(cache_dir: PathBuf) -> Self`: Create empty state with no hashes.
    - `compute_dirty(&self, current_hashes: &HashMap<FunctionId, [u8; 32]>, call_graph: &HashMap<FunctionId, Vec<FunctionId>>) -> RecompilationPlan`:
      - Phase 1: Compare each function's current hash against last_compiled_hashes. Functions with changed or new hashes are "directly dirty."
      - Phase 2: Build reverse call graph. BFS from dirty functions through callers to find transitive dependents.
      - Phase 3: Everything else is cached.
    - `update_hashes(&mut self, hashes: HashMap<FunctionId, [u8; 32]>)`: Update last_compiled_hashes after successful compilation.
    - `cached_object_path(&self, func_id: FunctionId) -> PathBuf`: Return path to cached .o file.
    - `is_settings_changed(&self, settings: &CompileOptions) -> bool`: Check if compilation settings changed (invalidates entire cache).
    - `save(&self, path: &Path)` and `load(path: &Path) -> Option<Self>`: Persist/load incremental state as JSON to a file alongside the cache.

    Implement `build_call_graph(graph: &ProgramGraph) -> HashMap<FunctionId, Vec<FunctionId>>`:
    - Scan all functions. For each function's nodes, find Call { target } ops.
    - Return caller -> list of callees.

    Implement `compute_settings_hash(options: &CompileOptions) -> [u8; 32]`:
    - Hash opt level + target triple + debug flag to detect settings changes.

    **3. Export from lib.rs:**

    Add `pub mod incremental;` to `crates/lmlang-codegen/src/lib.rs`.

    **4. Modify compile() for incremental path (crates/lmlang-codegen/src/compiler.rs):**

    Add an `incremental: Option<&mut IncrementalState>` parameter to `compile()`. Keep the existing signature as the default (no incremental state = full compilation).

    Better approach: Add a new function `compile_incremental(graph, options, state: &mut IncrementalState)` that wraps the incremental logic, keeping `compile()` unchanged for backward compatibility:

    ```rust
    pub fn compile_incremental(
        graph: &ProgramGraph,
        options: &CompileOptions,
        state: &mut IncrementalState,
    ) -> Result<CompileResult, CodegenError> {
        // 1. Type check (same as compile)
        // 2. Check if settings changed -- if so, full rebuild and update state
        // 3. Compute current hashes using hash_all_functions_for_compilation
        // 4. Compute dirty plan using state.compute_dirty
        // 5. If no recompilation needed, skip codegen and link cached objects
        // 6. For dirty + dirty_dependent functions: compile each to its own
        //    LLVM Module (forward-declare all functions for cross-references),
        //    emit each to a separate .o file in state.cache_dir
        // 7. Link all .o files (fresh + cached) into final executable
        // 8. Update state with new hashes
    }
    ```

    For per-function compilation:
    - Create a fresh LLVM Context and Module for each dirty function
    - Forward-declare ALL function signatures in each Module (so cross-function calls resolve)
    - Compile only the target function's body
    - Emit to .o file named by function ID
    - The linker resolves cross-module symbol references

    Reuse the existing `compile_function` from codegen.rs (it already compiles one function at a time). Also reuse the existing forward_declare pattern from compiler.rs.

    **5. Write tests:**

    In the codegen test suite:
    - Test `build_call_graph`: create a program with A calls B, B calls C. Verify call graph is correct.
    - Test `compute_dirty`: create IncrementalState with old hashes, provide new hashes where one function changed. Verify dirty list and dependent list are correct.
    - Test that `compile_incremental` produces the same binary output as `compile` for the same graph (correctness baseline).
    - Test that after changing one function, only it and its callers recompile (check RecompilationPlan).
    - Test that contract-only changes (add a Precondition node) do NOT appear in dirty list (because hash_function_for_compilation excludes contracts).
  </action>
  <verify>
    Run `cargo test --workspace` -- all tests pass including new incremental compilation tests.

    Specifically verify: build_call_graph is correct, dirty detection works, per-function compilation produces working binaries, contract changes don't dirty functions.
  </verify>
  <done>
    IncrementalState tracks per-function hashes. RecompilationPlan identifies dirty/dependent/cached functions. build_call_graph correctly constructs caller-callee relationships. compile_incremental compiles only dirty functions to per-function object files, reuses cached .o files for clean functions, and links all into a working binary. Contract-only changes do not trigger recompilation. Tests verify correctness matches full compilation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dirty query API endpoint and server integration</name>
  <files>
    crates/lmlang-server/src/schema/compile.rs
    crates/lmlang-server/src/handlers/compile.rs
    crates/lmlang-server/src/service.rs
  </files>
  <action>
    **1. Add dirty status schema types (crates/lmlang-server/src/schema/compile.rs):**

    Add to the existing compile schema file:

    ```rust
    #[derive(Debug, Serialize)]
    pub struct DirtyStatusResponse {
        /// Functions that have changed since last compilation.
        pub dirty_functions: Vec<DirtyFunctionView>,
        /// Functions that need recompilation due to dependency changes.
        pub dirty_dependents: Vec<DirtyFunctionView>,
        /// Functions that can use cached object files.
        pub cached_functions: Vec<CachedFunctionView>,
        /// Whether any recompilation is needed.
        pub needs_recompilation: bool,
    }

    #[derive(Debug, Serialize)]
    pub struct DirtyFunctionView {
        pub function_id: u32,
        pub function_name: String,
        /// Why this function is dirty: "changed" or "dependent_of:<function_name>"
        pub reason: String,
    }

    #[derive(Debug, Serialize)]
    pub struct CachedFunctionView {
        pub function_id: u32,
        pub function_name: String,
    }
    ```

    **2. Add IncrementalState to ProgramService (service.rs):**

    Add an `incremental_state: Option<IncrementalState>` field to ProgramService. Initialize to None in `new()` and `in_memory()`. The state is created lazily on first incremental compile.

    Add method `dirty_status(&self) -> Result<DirtyStatusResponse, ApiError>`:
    - If no incremental_state, return all functions as dirty (no prior compilation).
    - Otherwise, compute current hashes, build call graph, compute dirty plan.
    - Map RecompilationPlan to DirtyStatusResponse with function names.

    Extend the existing `compile` method (or add `compile_incremental`) to use IncrementalState when available:
    - On first compile: do full compilation, initialize incremental_state.
    - On subsequent compiles: use compile_incremental with the stored state.
    - Optionally add an `incremental: bool` field to CompileRequest to let agents opt in/out.

    **3. Add dirty query handler (handlers/compile.rs):**

    Add a `dirty_status` handler:
    - GET /programs/:program_id/dirty
    - Lock AppState, call service.dirty_status()
    - Return ApiResponse::ok(response)

    Wire into the router alongside existing compile endpoint.

    **4. Write integration test:**

    In the server test suite:
    - Create a multi-function program (A calls B)
    - Compile it (full compilation)
    - Query dirty status -- should show needs_recompilation: false
    - Modify function B (add/change a node)
    - Query dirty status -- should show B as dirty, A as dirty_dependent
    - Compile again (incremental)
    - Query dirty status -- should show needs_recompilation: false again
  </action>
  <verify>
    Run `cargo test --workspace` -- all tests pass.

    Verify: dirty_status endpoint returns correct dirty/cached lists. After modifying one function, only it and dependents are dirty. After recompiling, dirty status clears.
  </verify>
  <done>
    GET /programs/{id}/dirty endpoint returns DirtyStatusResponse showing which functions are dirty, which are dirty dependents, and which are cached. ProgramService tracks IncrementalState across compilations. After editing a function, dirty status correctly identifies it and its callers. After incremental recompilation, dirty status clears. Integration test proves the full edit->query->compile->query cycle.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes all tests
2. build_call_graph correctly identifies caller-callee relationships from Call nodes
3. Dirty detection identifies changed functions and their transitive callers
4. Per-function object files are cached and reused for clean functions
5. Contract-only changes do NOT mark functions as dirty
6. GET /programs/{id}/dirty returns structured dirty status
7. Incremental compilation produces binaries identical in behavior to full compilation
8. Settings changes (opt level, target) invalidate the entire cache
</verification>

<success_criteria>
After editing a single function in a multi-function program, only that function and its dependents recompile (not the entire program). Agent can query which functions are dirty and see the recompilation plan before triggering a build. Contract changes do not mark functions dirty. Full recompilation remains as the fallback for first builds.
</success_criteria>

<output>
After completion, create `.planning/phases/06-full-contract-system-incremental-compilation/06-03-SUMMARY.md`
</output>

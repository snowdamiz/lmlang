---
phase: 06-full-contract-system-incremental-compilation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - crates/lmlang-check/Cargo.toml
  - crates/lmlang-check/src/contracts/property.rs
  - crates/lmlang-check/src/contracts/mod.rs
  - crates/lmlang-server/src/schema/contracts.rs
  - crates/lmlang-server/src/schema/mod.rs
  - crates/lmlang-server/src/handlers/contracts.rs
  - crates/lmlang-server/src/handlers/mod.rs
  - crates/lmlang-server/src/service.rs
  - crates/lmlang-server/src/router.rs
autonomous: true
requirements:
  - CNTR-05

must_haves:
  truths:
    - "Agent can provide seed inputs and edge cases, system generates randomized variations to test contracts"
    - "Agent specifies the iteration count -- no default, always required"
    - "Test results include detailed execution trace for each failure showing the path through the graph"
    - "Property tests run through the graph interpreter only -- no compiled execution"
    - "Given the same random seed, the same test inputs are generated (reproducibility)"
  artifacts:
    - path: "crates/lmlang-check/src/contracts/property.rs"
      provides: "Property test harness: config, result types, random input generation, test loop"
      exports: ["PropertyTestConfig", "PropertyTestResult", "PropertyTestFailure", "run_property_tests"]
    - path: "crates/lmlang-server/src/schema/contracts.rs"
      provides: "API schema types for property test request/response and contract violation views"
      exports: ["PropertyTestRequest", "PropertyTestResponse", "ContractViolationView"]
    - path: "crates/lmlang-server/src/handlers/contracts.rs"
      provides: "POST /programs/{id}/property-test handler"
      exports: ["property_test"]
  key_links:
    - from: "crates/lmlang-server/src/handlers/contracts.rs"
      to: "crates/lmlang-check/src/contracts/property.rs"
      via: "Handler calls run_property_tests through ProgramService"
      pattern: "run_property_tests|property_test"
    - from: "crates/lmlang-check/src/contracts/property.rs"
      to: "crates/lmlang-check/src/interpreter/state.rs"
      via: "Each test iteration runs the interpreter to check contracts"
      pattern: "Interpreter::new|interpreter.run"
---

<objective>
Implement the property-based testing harness that auto-generates randomized inputs from agent-provided seeds and runs them through the interpreter to verify contracts hold across input ranges.

Purpose: Agents can systematically test function contracts by providing seed inputs and edge cases, then letting the system explore the input space via randomized variations. Failures include full execution traces and counterexample values for debugging.

Output: Property test engine in lmlang-check, API endpoint for agents to trigger property tests, and reproducible test runs via deterministic PRNG.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-full-contract-system-incremental-compilation/06-RESEARCH.md
@.planning/phases/06-full-contract-system-incremental-compilation/06-01-SUMMARY.md

@crates/lmlang-check/src/contracts/mod.rs
@crates/lmlang-check/src/contracts/check.rs
@crates/lmlang-check/src/interpreter/state.rs
@crates/lmlang-check/src/interpreter/eval.rs
@crates/lmlang-check/src/lib.rs
@crates/lmlang-check/Cargo.toml
@crates/lmlang-server/src/service.rs
@crates/lmlang-server/src/handlers/mod.rs
@crates/lmlang-server/src/schema/mod.rs
@crates/lmlang-server/src/router.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Property test harness with random input generation</name>
  <files>
    crates/lmlang-check/Cargo.toml
    crates/lmlang-check/src/contracts/property.rs
    crates/lmlang-check/src/contracts/mod.rs
  </files>
  <action>
    **1. Add dependencies (crates/lmlang-check/Cargo.toml):**

    Add to `[dependencies]`:
    ```toml
    rand = "0.8"
    rand_chacha = "0.3"
    ```

    **2. Create property test harness (crates/lmlang-check/src/contracts/property.rs):**

    Define types:

    ```rust
    pub struct PropertyTestConfig {
        /// Agent-provided seed inputs (the "interesting" cases).
        pub seeds: Vec<Vec<Value>>,
        /// Number of randomized iterations to run (agent-specified, required -- no default).
        pub iterations: u32,
        /// Random seed for reproducibility (system generates if not provided).
        pub random_seed: u64,
    }

    pub struct PropertyTestResult {
        /// Total tests run (seeds + random variations).
        pub total_run: u32,
        /// Number of passing tests.
        pub passed: u32,
        /// All failures with full details.
        pub failures: Vec<PropertyTestFailure>,
        /// The random seed used (for reproducibility).
        pub random_seed: u64,
    }

    pub struct PropertyTestFailure {
        /// The inputs that caused the failure.
        pub inputs: Vec<Value>,
        /// The contract violation that occurred.
        pub violation: ContractViolation,
        /// Execution trace for this test case.
        pub trace: Vec<TraceEntry>,
    }
    ```

    Implement `generate_random_value(type_id: TypeId, registry: &TypeRegistry, rng: &mut ChaCha8Rng) -> Value`:
    - Bool: random true/false
    - I8: random i8, with boundary values (0, 1, -1, i8::MIN, i8::MAX) weighted into the mix
    - I16/I32/I64: same pattern with respective ranges
    - F32/F64: random float, with special values (0.0, -0.0, 1.0, -1.0) weighted in
    - Array: generate random elements of the element type (random length 0-10)
    - Struct: generate random values for each field
    - Other types: return a zero/default value

    Implement `generate_random_inputs(params: &[(String, TypeId)], registry: &TypeRegistry, rng: &mut ChaCha8Rng) -> Vec<Value>`:
    - Map each parameter to a random value of its type.

    Implement `run_property_tests(graph: &ProgramGraph, func_id: FunctionId, config: PropertyTestConfig) -> Result<PropertyTestResult, RuntimeError>`:
    - Initialize ChaCha8Rng from config.random_seed
    - Get function def to know parameter types
    - Run seed inputs first: for each seed, create Interpreter with tracing enabled, run the function, check if execution halted with ContractViolation
    - Then generate `config.iterations` random inputs and run each the same way
    - For each failure, capture: the inputs, the ContractViolation, and the execution trace
    - Return PropertyTestResult with totals

    The interpreter already halts with ContractViolation state from Plan 01. The property test harness just repeatedly creates interpreters and checks the result.

    **3. Export from contracts/mod.rs:**

    Add `pub mod property;` and re-export key types: `PropertyTestConfig`, `PropertyTestResult`, `PropertyTestFailure`, `run_property_tests`.

    **4. Write tests:**

    Test in property.rs:
    - Test that `generate_random_value` produces values of the correct type for each scalar type
    - Test that `run_property_tests` with a function that has `a >= 0` precondition finds violations when random negative inputs are generated (use enough iterations -- 100 should find negatives)
    - Test reproducibility: same random_seed produces same inputs and same failures
    - Test that seeds are run first (before random inputs)
  </action>
  <verify>
    Run `cargo test -p lmlang-check` -- all tests pass including new property test harness tests. Verify that property tests are reproducible (same seed = same results).
  </verify>
  <done>
    PropertyTestConfig, PropertyTestResult, PropertyTestFailure types exist. generate_random_value handles all scalar types. run_property_tests runs seed inputs then random variations through the interpreter. Failures include ContractViolation and execution trace. Tests demonstrate reproducibility via deterministic PRNG.
  </done>
</task>

<task type="auto">
  <name>Task 2: Property test API endpoint and server integration</name>
  <files>
    crates/lmlang-server/src/schema/contracts.rs
    crates/lmlang-server/src/schema/mod.rs
    crates/lmlang-server/src/handlers/contracts.rs
    crates/lmlang-server/src/handlers/mod.rs
    crates/lmlang-server/src/service.rs
    crates/lmlang-server/src/router.rs
  </files>
  <action>
    **1. Create API schema types (crates/lmlang-server/src/schema/contracts.rs):**

    ```rust
    #[derive(Debug, Deserialize)]
    pub struct PropertyTestRequest {
        /// Function to test.
        pub function_id: u32,
        /// Agent-provided seed inputs.
        pub seeds: Vec<Vec<serde_json::Value>>,
        /// Number of randomized iterations (required, no default).
        pub iterations: u32,
        /// Random seed for reproducibility (optional -- system generates if absent).
        #[serde(default)]
        pub random_seed: Option<u64>,
        /// Whether to include execution traces for failures.
        #[serde(default)]
        pub trace_failures: bool,
    }

    #[derive(Debug, Serialize)]
    pub struct PropertyTestResponse {
        pub total_run: u32,
        pub passed: u32,
        pub failed: u32,
        pub random_seed: u64,
        pub failures: Vec<PropertyTestFailureView>,
    }

    #[derive(Debug, Serialize)]
    pub struct PropertyTestFailureView {
        pub inputs: Vec<serde_json::Value>,
        pub violation: ContractViolationView,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub trace: Option<Vec<TraceEntryView>>,
    }

    #[derive(Debug, Serialize)]
    pub struct ContractViolationView {
        pub kind: String,  // "precondition", "postcondition", "invariant"
        pub contract_node: u32,
        pub function_id: u32,
        pub message: String,
        pub inputs: Vec<serde_json::Value>,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub actual_return: Option<serde_json::Value>,
        pub counterexample: Vec<(u32, serde_json::Value)>,
    }
    ```

    Add `pub mod contracts;` to schema/mod.rs.

    **2. Add property_test method to ProgramService (service.rs):**

    Add a method `property_test(&self, request: PropertyTestRequest) -> Result<PropertyTestResponse, ApiError>`:
    - Convert serde_json::Value seeds to interpreter Value using existing conversion logic (look at how SimulateRequest handles this)
    - Build PropertyTestConfig from request
    - If random_seed is None, generate one from system time (std::time::SystemTime)
    - Call `run_property_tests(&self.graph, FunctionId(request.function_id), config)`
    - Convert PropertyTestResult to PropertyTestResponse, mapping Values to serde_json::Value
    - If trace_failures is false, set trace to None in each failure view

    **3. Create handler (crates/lmlang-server/src/handlers/contracts.rs):**

    Implement `property_test` handler following the thin handler pattern:
    - Extract JSON body as PropertyTestRequest
    - Lock AppState, call service.property_test(request)
    - Return ApiResponse::ok(response)

    Add `pub mod contracts;` to handlers/mod.rs.

    **4. Wire route (router.rs):**

    Add `POST /programs/:program_id/property-test` route mapped to `handlers::contracts::property_test`.

    **5. Write integration test:**

    In the server test suite, add a test that:
    - Creates a function with a precondition (`a >= 0`)
    - Sends a property test request with seeds=[[5], [-1]] and iterations=50
    - Verifies the response includes at least 1 failure (the -1 seed)
    - Verifies the response includes random_seed for reproducibility
    - Verifies total_run = 2 (seeds) + 50 (random)
  </action>
  <verify>
    Run `cargo test --workspace` -- all tests pass including the new property test integration test.

    The property test endpoint responds correctly to POST requests with seed inputs and random iterations.
  </verify>
  <done>
    POST /programs/{id}/property-test endpoint exists and works. Agent can send seed inputs, specify iteration count (required), and get back structured results with failures, violations, traces, and reproducible random_seed. Integration test proves the full flow from HTTP request through interpreter-based property testing to structured response.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` passes all tests
2. Property test harness generates random inputs of correct types
3. Same random_seed produces same test results (reproducibility)
4. Agent-provided seeds are tested first, then random variations
5. Failures include ContractViolation details and execution traces
6. POST /programs/{id}/property-test endpoint returns structured results
7. Iteration count is required (no default)
</verification>

<success_criteria>
Property-based tests auto-generated from contracts verify graph behavior across randomized input ranges. Agent provides seed inputs and edge cases, system generates variations. Agent controls iteration count. Test results include detailed execution traces for failures. Tests run through the interpreter only. Results are reproducible via deterministic PRNG seeding.
</success_criteria>

<output>
After completion, create `.planning/phases/06-full-contract-system-incremental-compilation/06-02-SUMMARY.md`
</output>

---
phase: 06-full-contract-system-incremental-compilation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/lmlang-check/src/interpreter/state.rs
  - crates/lmlang-check/src/contracts/check.rs
  - .planning/REQUIREMENTS.md
autonomous: true
gap_closure: true
requirements: [CNTR-04]

must_haves:
  truths:
    - "When a Call node targets a function in a different module, check_invariants_for_value is invoked for each typed argument"
    - "Cross-module call with an invariant-violating argument halts execution with ContractViolation"
    - "Same-module calls do NOT trigger invariant checking (no performance overhead for internal calls)"
    - "REQUIREMENTS.md shows CNTR-02, CNTR-03, CNTR-04 as complete in both checkboxes and Traceability table"
  artifacts:
    - path: "crates/lmlang-check/src/interpreter/state.rs"
      provides: "Module boundary invariant checking in Call handling"
      contains: "check_invariants_for_value"
    - path: ".planning/REQUIREMENTS.md"
      provides: "Updated requirement tracking"
      contains: "[x] **CNTR-02**"
  key_links:
    - from: "crates/lmlang-check/src/interpreter/state.rs"
      to: "crates/lmlang-check/src/contracts/check.rs"
      via: "check_invariants_for_value call in EvalResult::Call handler"
      pattern: "check_invariants_for_value"
---

<objective>
Wire module-boundary invariant checking into the interpreter and update REQUIREMENTS.md to reflect completed contract requirements.

Purpose: Close 2 gaps from 06-VERIFICATION.md -- (1) `check_invariants_for_value` is defined but never called, leaving CNTR-04 partially satisfied; (2) REQUIREMENTS.md has stale Pending status for CNTR-02/03/04.
Output: Working module-boundary invariant enforcement + accurate requirements tracking.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-full-contract-system-incremental-compilation/06-01-SUMMARY.md
@.planning/phases/06-full-contract-system-incremental-compilation/06-VERIFICATION.md
@crates/lmlang-check/src/interpreter/state.rs
@crates/lmlang-check/src/contracts/check.rs
@crates/lmlang-core/src/function.rs
@crates/lmlang-core/src/graph.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire module-boundary invariant checking into interpreter Call handling</name>
  <files>crates/lmlang-check/src/interpreter/state.rs, crates/lmlang-check/src/contracts/check.rs</files>
  <action>
In `state.rs`, in the `step()` method's `EvalResult::Call` handler (around line 311-343), add module-boundary invariant checking BEFORE pushing the new call frame (line 340). The logic:

1. Get the caller's FunctionId from `self.call_stack.last().unwrap().function_id`
2. Get the target FunctionId from the `target` variable (already available in the match arm)
3. Look up both FunctionDefs via `self.graph.get_function(caller_id)` and `self.graph.get_function(target)`
4. If both exist AND `caller_func.module != target_func.module` (cross-module call):
   a. For each argument in `args`, get its TypeId from the target function's `params` vec (index-matched)
   b. Build a `node_values` HashMap from the current frame's node_values (needed by `check_invariants_for_value`)
   c. Call `crate::contracts::check::check_invariants_for_value(self.graph, type_id, &arg_value, target, &node_values)` for each typed argument
   d. If any violations are returned, set `self.state = ExecutionState::ContractViolation { violation: violations[0].clone() }` and return early (do NOT push the new frame)
5. If same module or if either FunctionDef is not found, skip the check (no overhead for internal calls)

Add the necessary import for `check_invariants_for_value` at the top of state.rs:
`use crate::contracts::check::check_invariants_for_value;`

Also ensure `ContractViolation` derives `Clone` in `crates/lmlang-check/src/contracts/mod.rs` if it does not already (needed for `violations[0].clone()`). Check before adding.

Add a test in `state.rs`'s `#[cfg(test)] mod tests` block:
- `test_cross_module_invariant_violation`: Create a graph with two modules (module A, module B). Put a function `caller` in module A and a function `callee` in module B. Add an Invariant node in `callee`'s function that checks `target_type` matching the param type (e.g., I32) with a condition like `x >= 0`. Call `callee` from `caller` with argument `-1`. Assert that execution halts with `ExecutionState::ContractViolation` and the violation kind is `Invariant`.
- `test_same_module_no_invariant_check`: Same setup but both functions in the same module. Call with `-1`. Assert execution completes normally (invariant NOT checked at module boundary since same module).

Per user decision: "Invariant violations on data structures block compilation -- they are errors, not warnings." The ContractViolation halt is the correct behavior.
  </action>
  <verify>
Run `cargo test -p lmlang-check` -- all existing tests pass plus the 2 new tests pass. Specifically verify:
- `test_cross_module_invariant_violation` passes (violation detected)
- `test_same_module_no_invariant_check` passes (no violation for same-module)
- All 369+ existing tests still pass: `cargo test --workspace`
  </verify>
  <done>
`check_invariants_for_value` has at least 1 call site in the interpreter's Call handler. Cross-module calls with invariant-violating arguments produce ContractViolation. Same-module calls skip invariant checking. CNTR-04 is fully satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update REQUIREMENTS.md to reflect completed contract requirements</name>
  <files>.planning/REQUIREMENTS.md</files>
  <action>
Update `.planning/REQUIREMENTS.md`:

1. **Checkboxes** (lines 39-41): Change from `[ ]` to `[x]` for:
   - Line 39: `- [x] **CNTR-02**: Functions support pre-conditions as contract nodes checked at function entry`
   - Line 40: `- [x] **CNTR-03**: Functions support post-conditions as contract nodes checked at function return`
   - Line 41: `- [x] **CNTR-04**: Data structures support invariants checked at module boundaries`

2. **Traceability table** (lines 128-130): Change status from `Pending` to `Complete` for:
   - Line 128: `| CNTR-02 | Phase 6 | Complete |`
   - Line 129: `| CNTR-03 | Phase 6 | Complete |`
   - Line 130: `| CNTR-04 | Phase 6 | Complete |`

3. **Last updated** line (line 159): Change to `*Last updated: 2026-02-19 after phase 6 gap closure*`

No other changes. Do not modify any other lines.
  </action>
  <verify>
Read the file and confirm:
- Lines 39-41 all show `[x]`
- Lines 128-130 all show `Complete`
- No `Pending` status remains for any CNTR requirement
  </verify>
  <done>
REQUIREMENTS.md accurately reflects that CNTR-02, CNTR-03, CNTR-04, CNTR-05 are all complete. Traceability table matches checkbox state.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (existing 369+ plus 2 new)
2. `grep -n "check_invariants_for_value" crates/lmlang-check/src/interpreter/state.rs` -- at least 1 call site exists
3. `grep "CNTR-02\|CNTR-03\|CNTR-04" .planning/REQUIREMENTS.md` -- all show `[x]` and `Complete`
</verification>

<success_criteria>
- check_invariants_for_value is called during cross-module Call handling in the interpreter
- Cross-module calls with invariant-violating arguments halt with ContractViolation
- Same-module calls have zero invariant-checking overhead
- All existing tests continue to pass
- REQUIREMENTS.md accurately shows CNTR-02/03/04 as complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-full-contract-system-incremental-compilation/06-04-SUMMARY.md`
</output>

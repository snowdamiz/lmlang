---
phase: 06-full-contract-system-incremental-compilation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/lmlang-check/src/interpreter/state.rs
  - crates/lmlang-check/src/contracts/check.rs
  - .planning/REQUIREMENTS.md
autonomous: true
gap_closure: true
requirements: [CNTR-04]

must_haves:
  truths:
    - "When a Call node targets a function in a different module, invariants are evaluated for each typed argument"
    - "Cross-module call with an invariant-violating argument halts execution with ContractViolation"
    - "Same-module calls do NOT trigger invariant checking (no performance overhead for internal calls)"
    - "REQUIREMENTS.md shows CNTR-02, CNTR-03, CNTR-04 as complete in both checkboxes and Traceability table"
  artifacts:
    - path: "crates/lmlang-check/src/contracts/check.rs"
      provides: "evaluate_invariant_for_value function with mini-evaluation of condition subgraph"
      contains: "evaluate_invariant_for_value"
    - path: "crates/lmlang-check/src/interpreter/state.rs"
      provides: "Module boundary invariant checking in Call handling"
      contains: "evaluate_invariant_for_value"
    - path: ".planning/REQUIREMENTS.md"
      provides: "Updated requirement tracking"
      contains: "[x] **CNTR-02**"
  key_links:
    - from: "crates/lmlang-check/src/interpreter/state.rs"
      to: "crates/lmlang-check/src/contracts/check.rs"
      via: "evaluate_invariant_for_value call in EvalResult::Call handler"
      pattern: "evaluate_invariant_for_value"
---

<objective>
Wire module-boundary invariant checking into the interpreter and update REQUIREMENTS.md to reflect completed contract requirements.

Purpose: Close 2 gaps from 06-VERIFICATION.md -- (1) `check_invariants_for_value` is defined but never called AND has a fundamental evaluation bug (relies on pre-existing node_values from a frame that hasn't been entered yet, causing silent no-op), leaving CNTR-04 unsatisfied; (2) REQUIREMENTS.md has stale Pending status for CNTR-02/03/04.
Output: Working module-boundary invariant enforcement + accurate requirements tracking.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-full-contract-system-incremental-compilation/06-01-SUMMARY.md
@.planning/phases/06-full-contract-system-incremental-compilation/06-VERIFICATION.md
@crates/lmlang-check/src/interpreter/state.rs
@crates/lmlang-check/src/contracts/check.rs
@crates/lmlang-core/src/function.rs
@crates/lmlang-core/src/graph.rs
@crates/lmlang-core/src/ops.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add evaluate_invariant_for_value with mini-subgraph evaluation, then wire into interpreter Call handler</name>
  <files>crates/lmlang-check/src/contracts/check.rs, crates/lmlang-check/src/interpreter/state.rs</files>
  <action>
**CRITICAL CONTEXT (why the existing code cannot work):**

The existing `check_invariants_for_value` function finds Invariant nodes in `source_func`, then calls `evaluate_contract_condition(graph, contract_node_id, node_values)`. But `evaluate_contract_condition` walks backward from the Invariant node to find the source node connected to port 0, then looks up that source's value in `node_values`. At a cross-module call boundary, `node_values` comes from the *caller's* frame -- the callee's condition subgraph nodes (Parameter, Const, Compare, etc.) are NOT in the caller's frame. `evaluate_contract_condition` returns `Err(RuntimeError::MissingValue)`, which `check_invariants_for_value` silently swallows (`Err(_) => {}`). Result: always returns `Ok(vec![])`, zero violations, every time.

Preconditions/Postconditions work differently because they are *inline* graph nodes -- the interpreter's worklist evaluates their condition subgraph (Parameter -> Const -> Compare) as part of normal function execution, so by the time the Precondition/Postcondition node is reached, the condition source node already has a value in `node_values`.

For invariants at module boundaries, we need a different approach: **evaluate the invariant's condition subgraph on-the-fly** by walking the subgraph, substituting the concrete argument value for Parameter nodes, evaluating Const nodes to their literal values, and computing comparison/arithmetic nodes -- a mini-interpreter for the contract subgraph.

**Part A: Add `evaluate_invariant_for_value` to `check.rs`**

Add a new public function in `crates/lmlang-check/src/contracts/check.rs` (after `check_invariants_for_value`):

```rust
/// Evaluate an invariant's condition subgraph on-the-fly for a concrete value.
///
/// Unlike `evaluate_contract_condition` (which reads pre-computed node_values),
/// this function performs a mini-evaluation of the invariant's condition subgraph:
/// - Parameter nodes are substituted with `arg_value`
/// - Const nodes evaluate to their literal values
/// - Compare/arithmetic nodes are computed from their inputs
///
/// This is necessary at module boundaries because the callee's frame hasn't been
/// pushed yet, so normal worklist evaluation hasn't run for the callee's nodes.
pub fn evaluate_invariant_for_value(
    graph: &ProgramGraph,
    contract_node_id: NodeId,
    arg_value: &Value,
) -> Result<bool, RuntimeError> {
    // Mini-evaluate: walk the subgraph backward from the contract node,
    // then evaluate forward. Use a local node_values map.
    let mut local_values: HashMap<NodeId, Value> = HashMap::new();
    evaluate_subgraph_node(graph, contract_node_id, arg_value, &mut local_values)?;

    // Now check port 0 of the contract node (same logic as evaluate_contract_condition)
    let node_idx: petgraph::graph::NodeIndex<u32> = contract_node_id.into();
    for edge_ref in graph.compute().edges_directed(node_idx, Direction::Incoming) {
        if let FlowEdge::Data { target_port: 0, .. } = edge_ref.weight() {
            let source_id = NodeId::from(edge_ref.source());
            if let Some(value) = local_values.get(&source_id) {
                return match value {
                    Value::Bool(b) => Ok(*b),
                    _ => Err(RuntimeError::TypeMismatchAtRuntime {
                        node: contract_node_id,
                        expected: "Bool".into(),
                        got: value.type_name().into(),
                    }),
                };
            } else {
                return Err(RuntimeError::MissingValue { node: source_id, port: 0 });
            }
        }
    }
    // No condition edge -- treat as passed
    Ok(true)
}

/// Recursively evaluate a node in the invariant subgraph.
///
/// Walks backward through data edges to find dependencies, evaluates them first
/// (post-order), then evaluates this node. Results are cached in `local_values`.
fn evaluate_subgraph_node(
    graph: &ProgramGraph,
    node_id: NodeId,
    arg_value: &Value,
    local_values: &mut HashMap<NodeId, Value>,
) -> Result<(), RuntimeError> {
    // Already evaluated?
    if local_values.contains_key(&node_id) {
        return Ok(());
    }

    let node = graph.get_compute_node(node_id).ok_or_else(|| {
        RuntimeError::InternalError {
            message: format!("invariant subgraph node {} not found", node_id),
        }
    })?;
    let op = node.op.clone();

    match &op {
        ComputeNodeOp::Core(ComputeOp::Parameter { .. }) => {
            // Substitute with the argument value being checked
            local_values.insert(node_id, arg_value.clone());
        }
        ComputeNodeOp::Core(ComputeOp::Const { value: const_val }) => {
            local_values.insert(node_id, Value::from_const(const_val));
        }
        _ => {
            // Recursively evaluate all data input dependencies first
            let node_idx: petgraph::graph::NodeIndex<u32> = node_id.into();
            let incoming: Vec<(u16, NodeId)> = graph
                .compute()
                .edges_directed(node_idx, Direction::Incoming)
                .filter_map(|edge_ref| match edge_ref.weight() {
                    FlowEdge::Data { target_port, .. } => {
                        Some((*target_port, NodeId::from(edge_ref.source())))
                    }
                    _ => None,
                })
                .collect();

            for &(_, source_id) in &incoming {
                evaluate_subgraph_node(graph, source_id, arg_value, local_values)?;
            }

            // Gather inputs sorted by port
            let mut inputs: Vec<(u16, Value)> = incoming
                .iter()
                .filter_map(|(port, source_id)| {
                    local_values.get(source_id).map(|v| (*port, v.clone()))
                })
                .collect();
            inputs.sort_by_key(|(port, _)| *port);

            // Evaluate using the existing eval_op for arithmetic/comparison/etc.
            // Import: use super::eval::eval_op; (already available in the crate)
            use crate::interpreter::eval::eval_op;
            match eval_op(&op, &inputs, node_id, graph)? {
                Some(value) => { local_values.insert(node_id, value); }
                None => {} // Ops like contract nodes produce no value
            }
        }
    }
    Ok(())
}
```

Add the necessary imports at the top of `check.rs` if not already present:
- `use lmlang_core::ops::ComputeNodeOp;` (already have `ComputeOp` imported)
- `use crate::interpreter::value::Value;` (already imported)
- `use crate::interpreter::error::RuntimeError;` (already imported)

Check that `Value::from_const` is accessible (it is -- defined in `crate::interpreter::value`).
Check that `crate::interpreter::eval::eval_op` is pub(crate) or pub -- if not, add `pub(crate)` visibility to the `eval_op` function in `crates/lmlang-check/src/interpreter/eval.rs`.

**Part B: Update `check_invariants_for_value` to use the new function**

Replace the body of the `for contract_node_id in contract_nodes` loop in `check_invariants_for_value` to use `evaluate_invariant_for_value` instead of `evaluate_contract_condition`:

```rust
for contract_node_id in contract_nodes {
    match evaluate_invariant_for_value(graph, contract_node_id, _value) {
        Ok(true) => {}
        Ok(false) => {
            let message = get_contract_message(graph, contract_node_id);
            // Build counterexample from the mini-evaluated local values is not
            // straightforward here since we don't have access to local_values.
            // Instead, include the failing value itself as the counterexample.
            let counterexample = vec![(contract_node_id, _value.clone())];
            violations.push(ContractViolation {
                kind: ContractKind::Invariant,
                contract_node: contract_node_id,
                function_id: source_func,
                message,
                inputs: vec![_value.clone()],
                actual_return: None,
                counterexample,
            });
        }
        Err(_) => {
            // Subgraph evaluation failed -- this is now a real problem
            // (not a silent swallow). Log or propagate as needed.
            // For now, treat as a conservative failure: report violation.
            let message = get_contract_message(graph, contract_node_id);
            violations.push(ContractViolation {
                kind: ContractKind::Invariant,
                contract_node: contract_node_id,
                function_id: source_func,
                message,
                inputs: vec![_value.clone()],
                actual_return: None,
                counterexample: vec![],
            });
        }
    }
}
```

Also rename the `_value` parameter to `value` in the function signature (remove the underscore prefix) since it is now used.

Remove the `node_values: &HashMap<NodeId, Value>` parameter from `check_invariants_for_value` entirely -- it is no longer needed. The new signature becomes:

```rust
pub fn check_invariants_for_value(
    graph: &ProgramGraph,
    type_id: lmlang_core::type_id::TypeId,
    value: &Value,
    source_func: FunctionId,
) -> Result<Vec<ContractViolation>, RuntimeError> {
```

**Part C: Wire into interpreter's Call handler in `state.rs`**

In `state.rs`, in the `step()` method's `EvalResult::Call` handler (lines 311-343), add module-boundary invariant checking AFTER the recursion depth check (line 337) but BEFORE pushing the new frame (line 340):

```rust
// --- Module-boundary invariant checking ---
// Check invariants for arguments crossing module boundaries.
// Must happen BEFORE pushing the callee frame because invariant subgraphs
// are evaluated on-the-fly (the callee frame doesn't exist yet).
if let (Some(caller_frame), Some(caller_func), Some(target_func)) = (
    self.call_stack.last(),
    self.call_stack.last().map(|f| f.function_id).and_then(|fid| self.graph.get_function(fid)),
    self.graph.get_function(target),
) {
    if caller_func.module != target_func.module {
        // Cross-module call: check invariants for each typed argument
        for (idx, arg_value) in args.iter().enumerate() {
            if let Some((_, type_id)) = target_func.params.get(idx) {
                let violations = crate::contracts::check::check_invariants_for_value(
                    self.graph, *type_id, arg_value, target,
                )?;
                if let Some(violation) = violations.into_iter().next() {
                    self.state = ExecutionState::ContractViolation { violation };
                    return &self.state;
                }
            }
        }
    }
}
// --- End module-boundary invariant checking ---
```

Note: Since we removed the `node_values` parameter from `check_invariants_for_value`, the call no longer needs to pass a HashMap. The function now self-evaluates the invariant subgraph.

**Part D: Add tests in `check.rs`**

Add these tests to the existing `#[cfg(test)] mod tests` block in `check.rs`:

1. `test_evaluate_invariant_for_value_passes`: Build a graph with a function containing an Invariant node with condition `x >= 0` (Parameter -> Const(0) -> Compare(Ge) -> Invariant). Call `evaluate_invariant_for_value` with `Value::I32(5)`. Assert it returns `Ok(true)`.

2. `test_evaluate_invariant_for_value_fails`: Same graph. Call with `Value::I32(-1)`. Assert it returns `Ok(false)`.

3. `test_check_invariants_for_value_with_mini_eval`: Build a graph with a function containing an Invariant node typed to I32 with condition `x >= 0`. Call `check_invariants_for_value(graph, TypeId::I32, &Value::I32(-1), func_id)`. Assert it returns 1 violation with kind `Invariant`.

**Part E: Add integration tests in `state.rs`**

Add these tests to the existing `#[cfg(test)] mod tests` block in `state.rs`:

1. `test_cross_module_invariant_violation`: Build a graph with two modules:
   - `graph.add_module("mod_b".into(), root, Visibility::Public)` to create module B
   - Add function `caller` in root module (module A), function `callee` in module B
   - `callee` has one param `(x, TypeId::I32)` and an Invariant node with condition `x >= 0` (built the same way as precondition tests: Parameter(0) -> Const(0) -> Compare(Ge) -> Invariant node with `target_type: TypeId::I32`)
   - `callee` also has a Return node returning the parameter
   - `caller` has a Call node targeting `callee`, with a Const(-1) feeding port 0
   - Run the interpreter starting at `caller` with no args
   - Assert state is `ExecutionState::ContractViolation` with `violation.kind == ContractKind::Invariant`

2. `test_same_module_no_invariant_check`: Same graph structure but both functions in the same module (root). Call `callee(-1)` from `caller`. Assert execution completes normally with `ExecutionState::Completed` (invariant NOT checked for same-module calls). The invariant condition subgraph is still present but since it is a same-module call, the invariant check is skipped entirely. The Invariant node will be encountered during normal execution but since `x = -1` makes the condition `false`, this will produce a ContractViolation through the normal inline Invariant node evaluation. **WAIT** -- this means the Invariant node IS still evaluated inline. For same-module calls, the normal worklist-based execution will still evaluate the Invariant node and halt. This is actually the correct behavior per user decisions ("Invariant violations on data structures block compilation -- they are errors, not warnings"). So instead, build this test WITHOUT an Invariant node in the callee to confirm same-module calls skip the module-boundary check. OR, to properly test the difference: use the same graph but verify that for same-module calls, the module-boundary check code path is NOT entered (the invariant may still trigger via inline evaluation, which is fine). Better approach: verify the distinction with a callee that has an invariant but receives a VALID argument. For same-module: should complete normally (invariant passes inline). For cross-module: should also complete normally (invariant passes at boundary). The REAL test of "same-module skip" is a timing test -- the boundary check doesn't run. We can verify this indirectly: create a same-module test with invariant and valid args, confirm Completed. Already covered by the cross-module test showing violations work.

   **Simplified approach:** Just one integration test (`test_cross_module_invariant_violation`) that proves the critical path works. The unit tests in `check.rs` cover the evaluation mechanics. Same-module non-triggering is implicitly tested by ALL existing tests (none of them trigger module-boundary invariant checking since they're all same-module).

Per user decision: "Invariant violations on data structures block compilation -- they are errors, not warnings." The ContractViolation halt is the correct behavior.
  </action>
  <verify>
1. `cargo test -p lmlang-check -- test_evaluate_invariant_for_value` passes (both pass and fail cases)
2. `cargo test -p lmlang-check -- test_check_invariants_for_value_with_mini_eval` passes
3. `cargo test -p lmlang-check -- test_cross_module_invariant_violation` passes
4. `cargo test --workspace` -- all 369+ existing tests still pass
5. `grep -n "evaluate_invariant_for_value" crates/lmlang-check/src/contracts/check.rs` shows the function definition
6. `grep -n "evaluate_invariant_for_value\|check_invariants_for_value" crates/lmlang-check/src/interpreter/state.rs` shows the call site
  </verify>
  <done>
Invariant condition subgraphs are evaluated on-the-fly at module boundaries using mini-subgraph evaluation (not pre-existing node_values). Cross-module calls with invariant-violating arguments produce ContractViolation. Same-module calls skip the boundary check. CNTR-04 is fully satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update REQUIREMENTS.md to reflect completed contract requirements</name>
  <files>.planning/REQUIREMENTS.md</files>
  <action>
Update `.planning/REQUIREMENTS.md`:

1. **Checkboxes** (lines 39-41): Change from `[ ]` to `[x]` for:
   - Line 39: `- [x] **CNTR-02**: Functions support pre-conditions as contract nodes checked at function entry`
   - Line 40: `- [x] **CNTR-03**: Functions support post-conditions as contract nodes checked at function return`
   - Line 41: `- [x] **CNTR-04**: Data structures support invariants checked at module boundaries`

2. **Traceability table** (lines 128-130): Change status from `Pending` to `Complete` for:
   - Line 128: `| CNTR-02 | Phase 6 | Complete |`
   - Line 129: `| CNTR-03 | Phase 6 | Complete |`
   - Line 130: `| CNTR-04 | Phase 6 | Complete |`

3. **Last updated** line (line 159): Change to `*Last updated: 2026-02-19 after phase 6 gap closure*`

No other changes. Do not modify any other lines.
  </action>
  <verify>
Read the file and confirm:
- Lines 39-41 all show `[x]`
- Lines 128-130 all show `Complete`
- No `Pending` status remains for any CNTR requirement
  </verify>
  <done>
REQUIREMENTS.md accurately reflects that CNTR-02, CNTR-03, CNTR-04, CNTR-05 are all complete. Traceability table matches checkbox state.
  </done>
</task>

</tasks>

<verification>
1. `cargo test --workspace` -- all tests pass (existing 369+ plus new tests)
2. `grep -n "evaluate_invariant_for_value" crates/lmlang-check/src/contracts/check.rs` -- function exists
3. `grep -n "evaluate_invariant_for_value\|check_invariants_for_value" crates/lmlang-check/src/interpreter/state.rs` -- at least 1 call site exists
4. `grep "CNTR-02\|CNTR-03\|CNTR-04" .planning/REQUIREMENTS.md` -- all show `[x]` and `Complete`
</verification>

<success_criteria>
- evaluate_invariant_for_value performs mini-subgraph evaluation (Parameter substitution + Const literal + arithmetic/comparison forwarding) without relying on pre-existing node_values
- check_invariants_for_value no longer takes a node_values parameter and uses evaluate_invariant_for_value internally
- Cross-module calls with invariant-violating arguments halt with ContractViolation
- Same-module calls have zero invariant-checking overhead (boundary check skipped)
- All existing tests continue to pass
- REQUIREMENTS.md accurately shows CNTR-02/03/04 as complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-full-contract-system-incremental-compilation/06-04-SUMMARY.md`
</output>

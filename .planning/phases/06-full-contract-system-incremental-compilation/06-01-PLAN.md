---
phase: 06-full-contract-system-incremental-compilation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/lmlang-core/src/ops.rs
  - crates/lmlang-check/src/contracts/mod.rs
  - crates/lmlang-check/src/contracts/check.rs
  - crates/lmlang-check/src/lib.rs
  - crates/lmlang-check/src/interpreter/state.rs
  - crates/lmlang-check/src/interpreter/eval.rs
  - crates/lmlang-check/src/typecheck/mod.rs
  - crates/lmlang-codegen/src/codegen.rs
  - crates/lmlang-storage/src/hash.rs
autonomous: true
requirements:
  - CNTR-02
  - CNTR-03
  - CNTR-04

must_haves:
  truths:
    - "Precondition nodes are first-class ComputeOp variants that agents create via existing mutation API"
    - "Postcondition nodes are first-class ComputeOp variants checked at function return"
    - "Invariant nodes are first-class ComputeOp variants associated with TypeIds and checked at module boundaries"
    - "Contract violations produce structured diagnostics with counterexample values, node IDs, and inputs"
    - "Compiled binaries contain zero contract overhead -- contract nodes are stripped during codegen"
    - "Contract changes do not mark functions dirty for recompilation"
  artifacts:
    - path: "crates/lmlang-core/src/ops.rs"
      provides: "Precondition, Postcondition, Invariant variants on ComputeOp + is_contract() helper"
      contains: "Precondition"
    - path: "crates/lmlang-check/src/contracts/mod.rs"
      provides: "ContractViolation, ContractKind types for structured violation diagnostics"
      exports: ["ContractViolation", "ContractKind"]
    - path: "crates/lmlang-check/src/contracts/check.rs"
      provides: "Contract checking logic: find contract nodes, evaluate subgraphs, produce violations"
      exports: ["check_preconditions", "check_postconditions", "check_invariants"]
    - path: "crates/lmlang-storage/src/hash.rs"
      provides: "hash_function_for_compilation excluding contract nodes"
      contains: "hash_function_for_compilation"
  key_links:
    - from: "crates/lmlang-check/src/interpreter/state.rs"
      to: "crates/lmlang-check/src/contracts/check.rs"
      via: "Contract checking at function entry/return"
      pattern: "check_preconditions|check_postconditions"
    - from: "crates/lmlang-codegen/src/codegen.rs"
      to: "crates/lmlang-core/src/ops.rs"
      via: "is_contract() filter before topological sort"
      pattern: "is_contract"
    - from: "crates/lmlang-storage/src/hash.rs"
      to: "crates/lmlang-core/src/ops.rs"
      via: "is_contract() filter for compilation hash"
      pattern: "is_contract"
---

<objective>
Add contract node types (Precondition, Postcondition, Invariant) to the core op set and wire them into the interpreter for development-time checking, the codegen pipeline for filtering, and the storage layer for contract-aware hashing.

Purpose: Establishes the foundation for behavioral contracts as first-class graph nodes. Functions gain pre/post-conditions checked during interpretation, data structures gain invariants checked at module boundaries, and the compiler correctly ignores contract nodes to produce zero-overhead binaries.

Output: Three new ComputeOp variants, interpreter contract checking at function entry/return/module boundaries, codegen contract filtering, and contract-aware hash computation.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-full-contract-system-incremental-compilation/06-RESEARCH.md

@crates/lmlang-core/src/ops.rs
@crates/lmlang-core/src/lib.rs
@crates/lmlang-check/src/interpreter/state.rs
@crates/lmlang-check/src/interpreter/eval.rs
@crates/lmlang-check/src/typecheck/mod.rs
@crates/lmlang-check/src/lib.rs
@crates/lmlang-codegen/src/codegen.rs
@crates/lmlang-codegen/src/compiler.rs
@crates/lmlang-storage/src/hash.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Contract op types, codegen filtering, and contract-aware hashing</name>
  <files>
    crates/lmlang-core/src/ops.rs
    crates/lmlang-check/src/contracts/mod.rs
    crates/lmlang-check/src/lib.rs
    crates/lmlang-check/src/typecheck/mod.rs
    crates/lmlang-codegen/src/codegen.rs
    crates/lmlang-storage/src/hash.rs
  </files>
  <action>
    **1. Add contract op variants to ComputeOp (crates/lmlang-core/src/ops.rs):**

    Add three new variants to the `ComputeOp` enum after the CaptureAccess variant, in a new `// -- Contracts --` section:

    ```rust
    // -- Contracts (development-time only) --
    /// Precondition check at function entry.
    /// Port 0 (input): Bool -- the condition that must be true.
    /// No output -- check node only. Evaluated by interpreter before function body.
    /// Skipped by compiler (zero overhead in compiled binaries).
    Precondition {
        /// Human-readable contract description for diagnostics.
        message: String,
    },
    /// Postcondition check at function return.
    /// Port 0 (input): Bool -- the condition that must be true.
    /// Port 1 (input): The return value being checked.
    /// No output. Evaluated by interpreter after return value computed.
    /// Skipped by compiler.
    Postcondition {
        /// Human-readable contract description for diagnostics.
        message: String,
    },
    /// Data structure invariant.
    /// Port 0 (input): Bool -- the invariant condition.
    /// Port 1 (input): The value being checked.
    /// No output. Checked at module boundaries during interpretation.
    /// Violations block compilation (errors, not warnings).
    Invariant {
        /// The type this invariant constrains.
        target_type: TypeId,
        /// Human-readable invariant description for diagnostics.
        message: String,
    },
    ```

    Add an `is_contract()` method to `ComputeOp`:
    ```rust
    /// Returns `true` if this op is a contract node (dev-only, skipped by compiler).
    pub fn is_contract(&self) -> bool {
        matches!(self, ComputeOp::Precondition { .. } | ComputeOp::Postcondition { .. } | ComputeOp::Invariant { .. })
    }
    ```

    Also add `is_contract()` to `ComputeNodeOp`:
    ```rust
    /// Returns `true` if this is a contract node (development-time only).
    pub fn is_contract(&self) -> bool {
        matches!(self, ComputeNodeOp::Core(op) if op.is_contract())
    }
    ```

    **2. Create contracts module in lmlang-check (crates/lmlang-check/src/contracts/mod.rs):**

    Create directory `crates/lmlang-check/src/contracts/` and `mod.rs` containing:

    - `ContractKind` enum: `Precondition`, `Postcondition`, `Invariant` (with Serialize, Deserialize, Debug, Clone, Copy)
    - `ContractViolation` struct (Serialize, Deserialize, Debug, Clone):
      - `kind: ContractKind`
      - `contract_node: NodeId` -- the contract node that failed
      - `function_id: FunctionId` -- function containing the contract
      - `message: String` -- human-readable description from the contract op
      - `inputs: Vec<Value>` -- function inputs that triggered violation
      - `actual_return: Option<Value>` -- for postconditions, the actual return value
      - `counterexample: Vec<(NodeId, Value)>` -- node values from failing evaluation (sorted by NodeId for determinism)

    Re-export from `contracts/mod.rs`: `ContractViolation`, `ContractKind`.

    **3. Update lmlang-check lib.rs:**

    Add `pub mod contracts;` to `crates/lmlang-check/src/lib.rs`.

    **4. Add type checking rules for contract ops (crates/lmlang-check/src/typecheck/mod.rs):**

    In the exhaustive match over `ComputeOp` variants in the type rule resolution, add cases for:
    - `Precondition`: expects 1 input (port 0: Bool). No output type.
    - `Postcondition`: expects 2 inputs (port 0: Bool, port 1: any type matching function return). No output type.
    - `Invariant`: expects 2 inputs (port 0: Bool, port 1: value of target_type). No output type.

    Contract nodes produce no output edges (they are check-only nodes). The type checker should allow them to exist in the graph with no outgoing data edges.

    **5. Filter contract nodes in codegen (crates/lmlang-codegen/src/codegen.rs):**

    In `compile_function`, after collecting function nodes with `graph.function_nodes(func_id)`, filter out contract nodes BEFORE topological sort:

    ```rust
    let func_nodes: Vec<NodeId> = func_nodes.into_iter()
        .filter(|node_id| {
            if let Some(node) = graph.get_compute_node(*node_id) {
                !node.op.is_contract()
            } else {
                true
            }
        })
        .collect();
    ```

    This ensures contract nodes never reach the LLVM IR emitter. No new match arms needed in the codegen dispatch -- the nodes simply aren't there.

    **6. Add contract-aware hashing (crates/lmlang-storage/src/hash.rs):**

    Add a new public function `hash_function_for_compilation` that mirrors `hash_function` but excludes contract nodes:

    ```rust
    /// Computes a function hash EXCLUDING contract nodes.
    /// Used for incremental compilation dirty detection.
    /// Contract changes do NOT mark functions dirty (contracts are dev-only).
    pub fn hash_function_for_compilation(graph: &ProgramGraph, func_id: FunctionId) -> blake3::Hash {
        // Same logic as hash_function but filter out nodes where op.is_contract()
    }
    ```

    Also add `hash_all_functions_for_compilation` that calls it for every function (mirrors `hash_all_functions`).

    Import `ComputeNodeOp` if not already imported -- use `is_contract()` for the filter predicate.
  </action>
  <verify>
    Run `cargo build --workspace` to verify all new types compile, the codegen dispatch has no exhaustiveness warnings, and the hash module compiles.

    Run existing tests: `cargo test --workspace` -- all existing tests must still pass (the new variants don't break existing op handling because codegen filters them and the interpreter will handle them in Task 2).
  </verify>
  <done>
    Three new ComputeOp variants (Precondition, Postcondition, Invariant) exist with is_contract() helpers. ContractViolation and ContractKind types are defined in lmlang-check::contracts. Type checking rules are added for contract ops. Codegen filters out contract nodes before compilation. hash_function_for_compilation excludes contract nodes. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Interpreter contract checking at function entry, return, and module boundaries</name>
  <files>
    crates/lmlang-check/src/contracts/check.rs
    crates/lmlang-check/src/contracts/mod.rs
    crates/lmlang-check/src/interpreter/state.rs
    crates/lmlang-check/src/interpreter/eval.rs
  </files>
  <action>
    **1. Create contract checking logic (crates/lmlang-check/src/contracts/check.rs):**

    Implement contract checking as standalone functions that the interpreter calls:

    - `find_contract_nodes(graph: &ProgramGraph, func_id: FunctionId, kind: ContractKind) -> Vec<NodeId>`: Scan function nodes, return those matching the specified contract kind. Sort by NodeId for deterministic ordering.

    - `evaluate_contract_subgraph(graph: &ProgramGraph, contract_node_id: NodeId, node_values: &HashMap<NodeId, Value>) -> Result<bool, RuntimeError>`: Given a contract node and the current node values in the frame, walk backward from port 0 of the contract node through data edges to find all nodes in the contract subgraph. Evaluate any unevaluated nodes in topological order (reusing `eval_op` from the interpreter). Return true if port 0 is `Value::Bool(true)`, false otherwise.

    - `collect_counterexample(contract_node_id: NodeId, node_values: &HashMap<NodeId, Value>) -> Vec<(NodeId, Value)>`: Collect all node values from the contract subgraph evaluation, sorted by NodeId. These form the counterexample in the violation diagnostic.

    - `check_preconditions(graph: &ProgramGraph, func_id: FunctionId, args: &[Value], node_values: &HashMap<NodeId, Value>) -> Result<Vec<ContractViolation>, RuntimeError>`: Find all precondition nodes for the function. For each, evaluate its subgraph. If the result is false, construct a ContractViolation with kind=Precondition, the contract message, the function args as inputs, and the counterexample values.

    - `check_postconditions(graph: &ProgramGraph, func_id: FunctionId, return_value: &Value, args: &[Value], node_values: &HashMap<NodeId, Value>) -> Result<Vec<ContractViolation>, RuntimeError>`: Same pattern for postconditions. The actual_return field is set to Some(return_value).

    - `check_invariants_for_value(graph: &ProgramGraph, type_id: TypeId, value: &Value, source_func: FunctionId, target_func: FunctionId) -> Result<Vec<ContractViolation>, RuntimeError>`: Find all Invariant nodes with matching target_type. Evaluate each invariant's subgraph with the value bound to port 1. If false, produce ContractViolation with kind=Invariant.

    Export check.rs from contracts/mod.rs: `pub mod check;`

    **2. Add ExecutionState::ContractViolation variant (crates/lmlang-check/src/interpreter/state.rs):**

    Add a new variant to `ExecutionState`:
    ```rust
    /// Execution halted due to a contract violation (development-time feedback).
    /// Distinct from Error (runtime crash) -- this is expected feedback about
    /// violated behavioral contracts.
    ContractViolation {
        violation: crate::contracts::ContractViolation,
    },
    ```

    **3. Wire precondition checking into function entry (state.rs):**

    In the interpreter's function call handling (where `Call` nodes are processed and a new CallFrame is pushed), AFTER parameter nodes are seeded but BEFORE body nodes are scheduled:

    - Call `check_preconditions(graph, func_id, &args, &frame.node_values)`.
    - If any violations are returned, set `self.state = ExecutionState::ContractViolation { violation: violations[0].clone() }` and return (halt execution). Report the first violation -- the agent can fix and re-run.

    **4. Wire postcondition checking into function return (state.rs):**

    In the interpreter's Return node handling, AFTER the return value is computed but BEFORE it is delivered to the caller:

    - Call `check_postconditions(graph, func_id, &return_value, &frame.arguments, &frame.node_values)`.
    - If any violations, set ContractViolation state and return.

    **5. Wire invariant checking into cross-module calls (state.rs):**

    When a Call node passes arguments to a function in a different module (check `graph.get_function(caller_func).module != graph.get_function(target_func).module` if module info is available on FunctionDef), check invariants on any argument whose type has associated invariants. Similarly check the return value when returning across module boundaries.

    If module tracking is not available on FunctionDef (check the struct), skip invariant checking for now and add a TODO -- invariants can be tested manually by calling check_invariants_for_value. The critical path is preconditions and postconditions.

    **6. Handle contract ops in eval.rs:**

    Add match arms for `ComputeOp::Precondition { .. }`, `ComputeOp::Postcondition { .. }`, and `ComputeOp::Invariant { .. }` in `eval_core_op`. These should return `Ok(None)` (no output value) since contracts are check nodes evaluated separately by the contract checking hooks, not by the normal work-list flow.

    **7. Write tests:**

    Add tests in `crates/lmlang-check/src/contracts/check.rs` (or a separate test module):

    - Test that a function with a precondition `a >= 0` halts with ContractViolation when called with a = -1.
    - Test that a function with a postcondition `result > 0` halts with ContractViolation when it returns 0.
    - Test that a function with valid inputs and valid return passes both pre and post conditions.
    - Test that ContractViolation includes the correct inputs, message, and counterexample values.
  </action>
  <verify>
    Run `cargo test --workspace` -- all tests pass including new contract checking tests.

    Specifically verify: precondition violation halts with structured ContractViolation, postcondition violation halts with return value in diagnostics, valid contracts allow normal execution.
  </verify>
  <done>
    Interpreter checks preconditions at function entry and postconditions at function return. Contract violations produce structured ContractViolation diagnostics with kind, node IDs, inputs, actual return values, and counterexample values. Invariant checking infrastructure exists (module boundary check may be deferred if FunctionDef lacks module info). At least 4 contract checking tests pass. All existing interpreter tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --workspace` succeeds with no warnings about exhaustive matches
2. `cargo test --workspace` passes all existing + new tests
3. Precondition/Postcondition/Invariant are in ComputeOp enum
4. ContractViolation diagnostics include: kind, contract_node, function_id, message, inputs, actual_return, counterexample
5. Codegen skips contract nodes (no LLVM IR emitted for them)
6. hash_function_for_compilation excludes contract nodes from hash
7. Interpreter halts with ContractViolation on failed pre/post conditions
</verification>

<success_criteria>
Functions can have pre-condition contract nodes checked at function entry, post-condition contract nodes checked at function return, and invariant nodes associated with types. Contract violations produce structured diagnostics per the locked decision (problem description only, no fix suggestions). Compiled binaries have zero contract overhead. Contract changes do not affect compilation hashes.
</success_criteria>

<output>
After completion, create `.planning/phases/06-full-contract-system-incremental-compilation/06-01-SUMMARY.md`
</output>

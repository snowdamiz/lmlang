---
phase: 03-type-checking-graph-interpreter
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - crates/lmlang-check/src/interpreter/mod.rs
  - crates/lmlang-check/src/interpreter/state.rs
  - .planning/REQUIREMENTS.md
  - .planning/phases/03-type-checking-graph-interpreter/03-02-SUMMARY.md
autonomous: true
requirements: [EXEC-01]
gap_closure: true

must_haves:
  truths:
    - "A graph with ComputeOp::Loop, a loop condition, back-edge, and accumulator produces the correct accumulated result and terminates when the condition becomes false"
    - "EXEC-01 is marked Complete in REQUIREMENTS.md traceability table"
  artifacts:
    - path: "crates/lmlang-check/src/interpreter/mod.rs"
      provides: "Integration test for real Loop op with back-edge iteration"
      contains: "integration_loop_with_real_loop_op"
    - path: "crates/lmlang-check/src/interpreter/state.rs"
      provides: "Loop back-edge re-evaluation support"
      contains: "evaluated.remove"
    - path: ".planning/REQUIREMENTS.md"
      provides: "EXEC-01 marked Complete"
      contains: "| EXEC-01 | Phase 3 | Complete |"
  key_links:
    - from: "crates/lmlang-check/src/interpreter/state.rs"
      to: "ComputeOp::Loop in propagate_control_flow"
      via: "Loop branch 0 (continue) clears evaluated state for loop body nodes, enabling re-evaluation"
      pattern: "ComputeOp::Loop"
---

<objective>
Close 2 verification gaps from Phase 3: (1) add a real Loop op integration test with back-edge iteration that exercises the Loop implementation in state.rs, fixing any bugs in the re-evaluation logic required for loop body nodes to execute multiple iterations; (2) update requirements tracking for EXEC-01.

Purpose: Verification found that `integration_loop_sum_1_to_n` avoids ComputeOp::Loop entirely (uses straight-line DAG), leaving the Loop op implementation untested end-to-end. The `evaluated` set in `try_schedule_node` prevents re-evaluation of nodes, which blocks loop back-edges from working. This plan fixes the re-evaluation logic and proves it with a real loop test.

Output: A passing integration test that builds a real loop graph (Loop op + back-edge + accumulator + condition) and verifies correct iteration; updated REQUIREMENTS.md with EXEC-01 marked Complete.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-checking-graph-interpreter/03-02-SUMMARY.md
@.planning/phases/03-type-checking-graph-interpreter/03-VERIFICATION.md
@crates/lmlang-check/src/interpreter/state.rs
@crates/lmlang-check/src/interpreter/mod.rs
@crates/lmlang-core/src/ops.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Loop back-edge re-evaluation and add real Loop integration test</name>
  <files>
    crates/lmlang-check/src/interpreter/state.rs
    crates/lmlang-check/src/interpreter/mod.rs
  </files>
  <action>
**Gap:** The `evaluated` HashSet in `try_schedule_node` (state.rs line 985) prevents nodes from being re-evaluated. For loops with back-edges, the Loop op's "continue" branch (branch_index=0) must clear the `evaluated` state of loop body nodes so they can execute again on the next iteration. Without this, back-edges are dead.

**Fix in state.rs — `propagate_control_flow` method:**

When the Loop op takes branch 0 (continue/body), after activating the control successors on that branch, clear the `evaluated` and `node_values` entries for all nodes reachable from the Loop's branch-0 control successors (the loop body). Also reset their `readiness` counters so data edges re-fire properly. This enables the work-list to re-schedule and re-evaluate loop body nodes on each iteration.

Specifically, in the `propagate_control_flow` method, after the existing `for (succ_id, edge_branch) in control_successors` loop, add logic: if the op is `ComputeOp::Loop` and `taken_branch == Some(0)` (continue), collect all nodes reachable via control edges from the activated successors (BFS/DFS through the loop body subgraph until hitting the Loop node again or a node outside the body), then for each such node:
- Remove from `frame.evaluated`
- Remove from `frame.node_values`
- Reset `frame.readiness` entry to 0
- Remove from `frame.control_ready` (they'll be re-activated by their predecessors)

Be careful NOT to clear the Loop node itself (only body nodes). The Loop node will be re-scheduled when its condition input is re-provided by the body's back-edge.

Also, the Loop node itself needs to be re-evaluable: after processing the continue branch, remove the Loop node from `evaluated` so it can be re-triggered when the condition is recomputed.

**Integration test in mod.rs — `integration_loop_with_real_loop_op`:**

Build a function `sum_loop(n: i32) -> i32` that computes `1 + 2 + ... + n` using a real loop:

Graph structure:
```
Parameter(0) -> n: i32

// Initial values
Const(0) -> initial_sum: i32
Const(1) -> initial_i: i32
Const(1) -> one: i32 (for incrementing)

// Loop node — takes condition on port 0
Loop — branch 0 (continue) -> body, branch 1 (exit) -> exit_phi

// Loop body:
//   Phi(sum_phi) — port 0: body sum, port 1: initial_sum (from before loop)
//   Phi(i_phi) — port 0: body i, port 1: initial_i (from before loop)
//   add_to_sum = sum_phi + i_phi  (accumulate)
//   next_i = i_phi + one           (increment)
//   cond = next_i <= n              (or: i_phi < n, then use next_i)
//   cond -> Loop (back-edge: data edge from cond to Loop port 0)
//   add_to_sum -> sum_phi port 0 (back-edge)
//   next_i -> i_phi port 0 (back-edge)

// Exit:
//   exit_phi — gets sum value on exit
//   Return <- exit_phi
```

Actually, given how the interpreter's Branch/Phi pattern works (Branch stores decision, Phi reads it), use a simpler but correct loop pattern:

Pattern that matches the interpreter's existing control flow model:
1. Const nodes for initial values (sum=0, i=1, increment=1)
2. Comparison node: `i <= n` (using `Compare { op: CmpOp::Le }`)
3. Loop node: takes comparison result on port 0
   - branch_index=0 (continue) -> control edge to the body Add nodes
   - branch_index=1 (exit) -> control edge to Return
4. Body: `sum = sum + i`, `i = i + 1`
5. Back-edge: body outputs feed back to comparison and Loop

Given the complexity of back-edges in a work-list model, the most pragmatic approach may be to use a bounded unrolled pattern OR adapt the graph to use the existing Branch+Phi+back-edge pattern that works for the interpreter. Study the Branch/Phi conditional test pattern and extend it with iteration.

**Alternative simpler approach:** If the back-edge re-evaluation proves too complex for the current work-list architecture, build the loop as a self-recursive function call instead and document that ComputeOp::Loop is an LLVM codegen hint (like IfElse) that the interpreter handles via recursion-to-self. The key requirement is that a graph with ComputeOp::Loop actually exercises that code path and produces correct results.

Test assertion: `sum_loop(5)` returns `I32(15)`, `sum_loop(1)` returns `I32(1)`, `sum_loop(0)` returns `I32(0)`.

Run: `cargo test -p lmlang-check integration_loop_with_real_loop_op`
  </action>
  <verify>
    `cargo test -p lmlang-check integration_loop_with_real_loop_op` passes.
    `cargo test -p lmlang-check` — all 112+ existing tests still pass (no regressions).
  </verify>
  <done>
    A real integration test using ComputeOp::Loop with actual iteration (not straight-line DAG or recursion workaround) passes and produces the correct accumulated result. The Loop code path in state.rs propagate_control_flow is exercised end-to-end.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update EXEC-01 requirements tracking</name>
  <files>
    .planning/REQUIREMENTS.md
    .planning/phases/03-type-checking-graph-interpreter/03-02-SUMMARY.md
  </files>
  <action>
**In `.planning/REQUIREMENTS.md`:**
Change line 132 from:
```
| EXEC-01 | Phase 3 | Pending |
```
to:
```
| EXEC-01 | Phase 3 | Complete |
```

Also update the EXEC-01 checkbox in the requirements list section from `[ ]` to `[x]`.

**In `.planning/phases/03-type-checking-graph-interpreter/03-02-SUMMARY.md`:**
Change:
```
requirements-completed: []
```
to:
```
requirements-completed: [EXEC-01]
```
  </action>
  <verify>
    `grep "EXEC-01" .planning/REQUIREMENTS.md` shows "Complete".
    `grep "requirements-completed" .planning/phases/03-type-checking-graph-interpreter/03-02-SUMMARY.md` shows "[EXEC-01]".
  </verify>
  <done>
    EXEC-01 is marked Complete in both REQUIREMENTS.md traceability table and 03-02-SUMMARY.md requirements-completed field. The checkbox in the requirements list is also checked.
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p lmlang-check` — all tests pass including new Loop integration test
2. `grep "EXEC-01" .planning/REQUIREMENTS.md` — shows "Complete"
3. `grep "requirements-completed" .planning/phases/03-type-checking-graph-interpreter/03-02-SUMMARY.md` — shows "[EXEC-01]"
4. The new test uses `ComputeOp::Loop` (not straight-line DAG) and verifies iteration + termination
</verification>

<success_criteria>
- integration_loop_with_real_loop_op test passes with ComputeOp::Loop exercised
- All 112+ existing tests pass (no regressions)
- EXEC-01 marked Complete in REQUIREMENTS.md
- 03-02-SUMMARY.md requirements-completed updated
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-checking-graph-interpreter/03-03-SUMMARY.md`
</output>

---
phase: 03-type-checking-graph-interpreter
plan: 02
type: tdd
wave: 2
depends_on:
  - 03-01
files_modified:
  - crates/lmlang-check/src/lib.rs
  - crates/lmlang-check/src/interpreter/mod.rs
  - crates/lmlang-check/src/interpreter/value.rs
  - crates/lmlang-check/src/interpreter/state.rs
  - crates/lmlang-check/src/interpreter/eval.rs
  - crates/lmlang-check/src/interpreter/error.rs
  - crates/lmlang-check/src/interpreter/trace.rs
autonomous: true
requirements:
  - EXEC-01

must_haves:
  truths:
    - "Interpreter executes a simple arithmetic function (add two i32s) and produces the correct result"
    - "Interpreter handles conditionals (IfElse/Branch) by evaluating only the taken branch"
    - "Interpreter handles loops with correct iteration and termination"
    - "Interpreter handles function calls with proper call stack frames and recursion"
    - "Integer overflow, divide-by-zero, and out-of-bounds access all trap with clear error messages including the node that caused it"
    - "Step-by-step execution can pause after each node, inspect intermediate values, then resume"
    - "Execution trace (when enabled) logs every node evaluation and its result"
    - "Recursion depth limit is configurable, defaults to 256, traps on exceed"
    - "Multi-function program with conditionals and loops produces same results as hand-computed expected outputs"
    - "Runtime errors include partial results (values computed before the error)"
  artifacts:
    - path: "crates/lmlang-check/src/interpreter/value.rs"
      provides: "Value enum for all runtime value types (Bool, I8-I64, F32, F64, Unit, Array, Struct, Enum, Pointer, FunctionRef, Closure)"
      contains: "enum Value"
    - path: "crates/lmlang-check/src/interpreter/state.rs"
      provides: "InterpreterState, CallFrame, InterpreterConfig, and the Interpreter struct with step()/run()/pause()"
      contains: "struct Interpreter"
    - path: "crates/lmlang-check/src/interpreter/eval.rs"
      provides: "Per-op evaluation logic with checked arithmetic and trap semantics"
      contains: "eval_op"
    - path: "crates/lmlang-check/src/interpreter/error.rs"
      provides: "RuntimeError enum with IntegerOverflow, DivideByZero, OutOfBoundsAccess, RecursionLimit variants"
      contains: "enum RuntimeError"
    - path: "crates/lmlang-check/src/interpreter/trace.rs"
      provides: "TraceEntry and execution trace recording"
      contains: "struct TraceEntry"
  key_links:
    - from: "crates/lmlang-check/src/interpreter/state.rs"
      to: "crates/lmlang-core/src/graph.rs"
      via: "Interpreter holds &ProgramGraph reference for graph traversal"
      pattern: "&'g ProgramGraph"
    - from: "crates/lmlang-check/src/interpreter/eval.rs"
      to: "crates/lmlang-core/src/ops.rs"
      via: "Exhaustive match on ComputeNodeOp for per-op evaluation"
      pattern: "ComputeNodeOp::Core|ComputeNodeOp::Structured"
    - from: "crates/lmlang-check/src/interpreter/state.rs"
      to: "crates/lmlang-check/src/interpreter/eval.rs"
      via: "step() calls eval_op for each ready node"
      pattern: "eval_op"
---

<objective>
Implement a graph interpreter that executes computational graphs with provided inputs, producing correct output values for arithmetic, logic, control flow, memory operations, and function calls.

Purpose: Enables development-time execution without LLVM (EXEC-01), with step-by-step debugging, execution traces, and trap-on-error semantics.
Output: Working interpreter with state machine execution, call stack, memory model, comprehensive tests including multi-function programs.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-type-checking-graph-interpreter/03-RESEARCH.md
@.planning/phases/03-type-checking-graph-interpreter/03-01-SUMMARY.md
@crates/lmlang-core/src/lib.rs
@crates/lmlang-core/src/ops.rs
@crates/lmlang-core/src/edge.rs
@crates/lmlang-core/src/types.rs
@crates/lmlang-core/src/type_id.rs
@crates/lmlang-core/src/graph.rs
@crates/lmlang-core/src/node.rs
@crates/lmlang-core/src/function.rs
@crates/lmlang-check/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Value enum, RuntimeError, CallFrame, InterpreterState, TraceEntry, and core Interpreter struct with step/run/pause</name>
  <files>
    crates/lmlang-check/src/lib.rs
    crates/lmlang-check/src/interpreter/mod.rs
    crates/lmlang-check/src/interpreter/value.rs
    crates/lmlang-check/src/interpreter/state.rs
    crates/lmlang-check/src/interpreter/error.rs
    crates/lmlang-check/src/interpreter/trace.rs
  </files>
  <action>
    **TDD: Write failing tests first, then implement.**

    Add `pub mod interpreter;` to `crates/lmlang-check/src/lib.rs`.

    **value.rs — Runtime value representation:**
    ```rust
    #[derive(Debug, Clone)]
    pub enum Value {
        Bool(bool),
        I8(i8),
        I16(i16),
        I32(i32),
        I64(i64),
        F32(f32),   // Actual f32 at runtime (not f64 like ConstValue)
        F64(f64),
        Unit,
        Array(Vec<Value>),
        Struct(Vec<Value>),           // Fields in declaration order
        Enum { variant: u32, payload: Box<Value> },
        Pointer(usize),              // Index into interpreter memory
        FunctionRef(FunctionId),
        Closure { function: FunctionId, captures: Vec<Value> },
    }
    ```
    Implement `Value::from_const(cv: &ConstValue) -> Value` conversion. Note: `ConstValue::F32(f64_bits)` converts to `Value::F32(bits as f32)` per Phase 1 decision. Also implement `Value::type_id(&self, registry: &TypeRegistry) -> TypeId` to get the TypeId of a runtime value.

    **error.rs — RuntimeError with trap semantics:**
    ```rust
    #[derive(Debug, thiserror::Error)]
    pub enum RuntimeError {
        #[error("integer overflow at node {node}")]
        IntegerOverflow { node: NodeId },
        #[error("divide by zero at node {node}")]
        DivideByZero { node: NodeId },
        #[error("out of bounds access at node {node}: index {index}, size {size}")]
        OutOfBoundsAccess { node: NodeId, index: usize, size: usize },
        #[error("recursion depth limit ({limit}) exceeded at node {node}")]
        RecursionLimitExceeded { node: NodeId, limit: usize },
        #[error("type mismatch at runtime: node {node}, expected {expected}, got {got}")]
        TypeMismatchAtRuntime { node: NodeId, expected: String, got: String },
        #[error("missing value: node {node} input port {port} has no value")]
        MissingValue { node: NodeId, port: u16 },
        #[error("function not found: {id:?}")]
        FunctionNotFound { id: FunctionId },
        #[error("no return node in function {function:?}")]
        NoReturnNode { function: FunctionId },
        #[error("internal error: {message}")]
        InternalError { message: String },
    }
    ```

    **trace.rs — Execution trace:**
    ```rust
    #[derive(Debug, Clone)]
    pub struct TraceEntry {
        pub node_id: NodeId,
        pub op_description: String,
        pub inputs: Vec<(u16, Value)>,
        pub output: Option<Value>,
    }
    ```

    **state.rs — InterpreterState, CallFrame, Interpreter struct:**

    `ExecutionState` enum:
    ```rust
    pub enum ExecutionState {
        Ready,
        Running,
        Paused { last_node: NodeId, last_value: Option<Value> },
        Completed { result: Value },
        Error { error: RuntimeError, partial_results: HashMap<NodeId, Value> },
    }
    ```
    `partial_results` included per discretion recommendation -- when a runtime error occurs, include all values computed before the error.

    `CallFrame` struct:
    ```rust
    pub struct CallFrame {
        pub function_id: FunctionId,
        pub node_values: HashMap<NodeId, Value>,
        pub arguments: Vec<Value>,
        pub return_target: Option<(NodeId, u16)>,  // caller node + port to receive return value
        pub work_list: VecDeque<NodeId>,            // nodes ready to evaluate
        pub readiness: HashMap<NodeId, usize>,      // node -> number of inputs ready
    }
    ```

    `InterpreterConfig`:
    ```rust
    pub struct InterpreterConfig {
        pub trace_enabled: bool,
        pub max_recursion_depth: usize,  // default: 256
    }
    impl Default for InterpreterConfig {
        fn default() -> Self {
            InterpreterConfig { trace_enabled: false, max_recursion_depth: 256 }
        }
    }
    ```

    `Interpreter` struct with lifetime on ProgramGraph reference:
    ```rust
    pub struct Interpreter<'g> {
        graph: &'g ProgramGraph,
        state: ExecutionState,
        call_stack: Vec<CallFrame>,
        memory: Vec<Value>,           // flat memory for Alloc/Load/Store
        trace: Option<Vec<TraceEntry>>,
        config: InterpreterConfig,
    }
    ```

    Implement:
    - `Interpreter::new(graph: &ProgramGraph, config: InterpreterConfig) -> Interpreter`
    - `Interpreter::start(&mut self, function_id: FunctionId, args: Vec<Value>)` — initialize first call frame with arguments, seed work list with Parameter nodes
    - `Interpreter::step(&mut self) -> &ExecutionState` — evaluate one ready node from the current frame's work list, update readiness of successors, handle state transitions
    - `Interpreter::run(&mut self) -> &ExecutionState` — loop calling step() until Completed, Error, or Paused
    - `Interpreter::pause(&mut self)` — set state to Paused after current step
    - `Interpreter::resume(&mut self)` — transition from Paused back to Running, continue with step()
    - `Interpreter::state(&self) -> &ExecutionState` — read current state
    - `Interpreter::trace(&self) -> Option<&[TraceEntry]>` — read execution trace

    The work-list algorithm within `step()`:
    1. Pop a node from `work_list` that has `readiness[node] == expected_input_count`
    2. Gather input values from `node_values` via incoming data edges
    3. Call `eval_op()` (from eval.rs, implemented in Task 2)
    4. Store result in `node_values`
    5. For data-flow successors: increment readiness, add to work_list if fully ready
    6. For control-flow successors (Branch/IfElse/Match): add only the TAKEN branch's successors
    7. For Call ops: push new CallFrame, seed its work list with target's Parameter nodes
    8. For Return ops: pop current frame, store return value in caller frame's return_target node, resume caller

    **Tests (RED first, then GREEN):**
    - Test Value::from_const for each ConstValue variant (Bool, I8, I16, I32, I64, F32, F64, Unit)
    - Test InterpreterConfig::default() has trace_enabled=false and max_recursion_depth=256
    - Test Interpreter::new creates Ready state
    - Test Interpreter::start transitions to Running state with correct frame
    - Test step on a single-node function (Const -> Return): produces Completed with correct value
    - Test pause/resume cycle: step once, pause, inspect state, resume, step to completion
    - Test trace_enabled=true records TraceEntries
    - Test trace_enabled=false produces no trace
  </action>
  <verify>
    `cargo test -p lmlang-check` -- all interpreter core tests pass, including step/run/pause/resume and trace recording
  </verify>
  <done>
    Interpreter struct exists with state machine execution model. step() evaluates one node at a time using work-list with readiness tracking. run() executes to completion. pause()/resume() support step-by-step debugging. Execution trace records when enabled. Config has 256-depth recursion limit default.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement per-op evaluation with checked arithmetic, control flow handling, memory model, function calls, and comprehensive integration tests</name>
  <files>
    crates/lmlang-check/src/interpreter/eval.rs
    crates/lmlang-check/src/interpreter/mod.rs
  </files>
  <action>
    **TDD: Write failing tests first, then implement.**

    **eval.rs — Per-op evaluation with exhaustive match:**

    Implement `eval_op(op: &ComputeNodeOp, inputs: &[(u16, Value)], node_id: NodeId, graph: &ProgramGraph) -> Result<Option<Value>, RuntimeError>` with exhaustive match (no wildcard arms):

    **Arithmetic (BinaryArith, UnaryArith):**
    - Use Rust's `checked_add`, `checked_sub`, `checked_mul`, `checked_div`, `checked_rem` for integers [LOCKED: trap on overflow]
    - Divide-by-zero: check `rhs == 0` before division/remainder, return `RuntimeError::DivideByZero { node }` [LOCKED]
    - Float ops: use standard arithmetic (no overflow trapping for floats, NaN/Inf are valid)
    - Support all numeric types: I8, I16, I32, I64, F32, F64
    - Bool inputs in arithmetic: coerce to I8(0 or 1) before operation

    **Comparison (Compare):**
    - Integer comparison via standard Rust operators
    - Float comparison via standard Rust operators (NaN comparisons follow IEEE 754)
    - Output: Value::Bool

    **Logic (BinaryLogic, Not):**
    - Bool: standard logical operations
    - Integer: bitwise operations (AND, OR, XOR, NOT as bitwise complement)

    **Shifts:**
    - Integer shift operations: shl, shr_logical (logical right shift), shr_arith (arithmetic right shift)
    - Shift amount must be non-negative and less than bit width (trap if not)

    **Control Flow (IfElse, Branch, Loop, Match, Jump, Phi):**
    - **IfElse/Branch**: Evaluate condition (port 0, must be Bool). Determine taken branch (0=then/true, 1=else/false). The step() method in state.rs handles adding only the taken branch's successors to the work list. eval_op for Branch returns None (no output value).
    - **Loop**: The interpreter handles loops via the work-list: loop body nodes re-enter the work list when the back-edge is followed. Loop condition (port 0) determines whether to continue or exit. Must detect and handle loop exit (when condition is false, follow the exit control edge not the back-edge).
    - **Match**: Evaluate discriminant (port 0). Determine which arm is taken based on discriminant value matching branch_index on control edges.
    - **Jump**: No-op for evaluation. Control flow handled by step() adding the jump target's successors.
    - **Phi**: Select the value from the incoming control flow path that was actually taken. Implementation: find which incoming control edge was traversed (based on which predecessor was evaluated) and return that predecessor's value.

    **Memory (Alloc, Load, Store, GetElementPtr):**
    - **Alloc**: Push Value::Unit to `interpreter.memory`, return Value::Pointer(address)
    - **Load**: Read from memory address, return the value. Trap on out-of-bounds [LOCKED].
    - **Store**: Write value to memory address. Trap on out-of-bounds [LOCKED]. Return None.
    - **GetElementPtr**: Compute new address based on base pointer and index. For arrays: base + index. For structs: base + field_index.

    **Functions (Call, IndirectCall, Return, Parameter):**
    - **Parameter { index }**: Return the argument value at `index` from the current CallFrame
    - **Call { target }**: Handled in step() by pushing a new CallFrame with arguments gathered from incoming data edges. eval_op returns None; the return value comes from the callee's Return node.
    - **IndirectCall**: Like Call but target function resolved from the function pointer value at port 0
    - **Return**: Return the input value (port 0). step() handles popping the frame and storing the value in the caller's return_target. Check recursion depth when pushing frames: if `call_stack.len() >= config.max_recursion_depth`, return `RuntimeError::RecursionLimitExceeded` [LOCKED].

    **I/O (Print, ReadLine, FileOpen, FileRead, FileWrite, FileClose):**
    - For the interpreter, I/O ops are mock-able. For now:
    - **Print**: Accept any input, store it in an I/O log (a `Vec<Value>` on the Interpreter), return Unit
    - **ReadLine**: Return a placeholder Value::I64(0) (no real stdin in interpreter)
    - **File ops**: Return placeholder values (file handle as I64, read data as I64)
    - The I/O log enables Phase 4's `simulate` API to capture output programmatically

    **Closures (MakeClosure, CaptureAccess):**
    - **MakeClosure { function }**: Gather captured values from data inputs, return Value::Closure { function, captures }
    - **CaptureAccess { index }**: Return the captured value at index from the current frame's closure captures

    **Structured ops (StructCreate, StructGet, StructSet, ArrayCreate, ArrayGet, ArraySet, Cast, EnumCreate, EnumDiscriminant, EnumPayload):**
    - **StructCreate**: Gather field values from inputs in port order, return Value::Struct(fields)
    - **StructGet { field_index }**: Extract field from Value::Struct by index
    - **StructSet { field_index }**: Clone struct, replace field, return new struct
    - **ArrayCreate { length }**: Gather element values from inputs, return Value::Array(elements). Verify length matches.
    - **ArrayGet**: Extract element by index from Value::Array. Trap on out-of-bounds [LOCKED]. Error includes index and array size.
    - **ArraySet**: Clone array, replace element at index, return new array. Trap on out-of-bounds.
    - **Cast { target_type }**: Convert between numeric types (widening/narrowing). Use Rust `as` casts for simplicity.
    - **EnumCreate { type_id, variant_index }**: Create Value::Enum with discriminant and optional payload
    - **EnumDiscriminant**: Extract variant index as Value::I32
    - **EnumPayload { variant_index }**: Extract payload from Value::Enum

    Add `io_log: Vec<Value>` field to Interpreter for capturing Print output.
    Add `Interpreter::io_log(&self) -> &[Value]` accessor.

    **Integration tests (RED first, then GREEN):**

    1. **Simple arithmetic:** Build a graph for `add(a: i32, b: i32) -> i32 { return a + b; }`. Execute with args [I32(3), I32(5)]. Assert result = I32(8).

    2. **Integer overflow trap:** Build `mul(a: i32, b: i32) -> i32 { return a * b; }`. Execute with args [I32(i32::MAX), I32(2)]. Assert RuntimeError::IntegerOverflow.

    3. **Divide by zero trap:** Build `div(a: i32, b: i32) -> i32 { return a / b; }`. Execute with args [I32(10), I32(0)]. Assert RuntimeError::DivideByZero with correct node.

    4. **Conditional (IfElse/Branch):** Build a function that takes a bool and two i32s, returns the first i32 if true, second if false. Execute with (true, 10, 20) -> 10 and (false, 10, 20) -> 20.

    5. **Loop:** Build a function that sums integers from 1 to N using a loop (accumulator + counter pattern). Execute with N=5, assert result = 15.

    6. **Multi-function call:** Build a program with `double(x) -> x * 2` and `quad(x) -> double(double(x))`. Execute quad(3) = 12.

    7. **Recursion:** Build factorial(n): if n <= 1, return 1, else return n * factorial(n-1). Execute factorial(5) = 120.

    8. **Recursion depth limit:** Execute factorial with a large n that exceeds the 256 limit. Assert RuntimeError::RecursionLimitExceeded.

    9. **Step-by-step execution:** Build the add function, use step() to advance one node at a time, verify intermediate state is inspectable between steps, verify Paused state works.

    10. **Execution trace:** Build add function with trace_enabled=true, run to completion, verify trace contains entries for each evaluated node with correct inputs and outputs.

    11. **Array operations:** Build a function that creates a 3-element array, gets element at index 1. Execute and verify correct element returned.

    12. **Array out-of-bounds:** Access element at index 5 in a 3-element array. Assert RuntimeError::OutOfBoundsAccess with index=5, size=3.

    13. **Struct operations:** Build a function that creates a struct with fields, gets a field, returns it. Verify correct field value.

    14. **Partial results on error:** Build a function with a sequence: a = 5, b = 10, c = a / 0. Assert error includes partial_results with a=5, b=10.

    15. **Memory operations:** Build a function using Alloc, Store, Load. Verify values persist in memory correctly.
  </action>
  <verify>
    `cargo test -p lmlang-check` -- all interpreter evaluation and integration tests pass, including multi-function programs with conditionals and loops
  </verify>
  <done>
    Interpreter executes all op types correctly. Checked arithmetic traps on overflow/div-by-zero/out-of-bounds per locked decisions. Control flow (IfElse, Loop, Match) evaluates only taken branches. Function calls use proper call stack with recursion limit. Step-by-step and trace work. Multi-function programs with conditionals and loops produce correct results matching hand-computed expected outputs (Phase 3 success criterion 3).
  </done>
</task>

</tasks>

<verification>
1. `cargo test -p lmlang-check` -- ALL tests pass (type checker + interpreter)
2. `cargo build -p lmlang-check` -- compiles with no warnings
3. Simple add(3, 5) = 8 via interpreter
4. factorial(5) = 120 via interpreter (recursion)
5. Sum 1..5 = 15 via interpreter (loop)
6. Conditional selects correct branch
7. Integer overflow, div-by-zero, out-of-bounds all trap with correct error details
8. Step/pause/resume works with inspectable intermediate values
9. Trace records every node evaluation when enabled
10. Recursion limit (256 default) traps correctly
11. Partial results included in runtime errors
</verification>

<success_criteria>
- Interpreter executes arbitrary computational graphs with correct results
- All op categories implemented: arithmetic, logic, comparison, shifts, control flow, memory, functions, I/O, closures, structured ops
- Checked arithmetic: overflow, div-by-zero, out-of-bounds all trap [LOCKED]
- State machine execution with step/run/pause/resume
- Call stack with frames, supporting recursion with configurable depth limit (default 256)
- Optional execution trace logging every node evaluation
- Runtime errors include partial results
- Multi-function program with conditionals and loops produces correct hand-verified results
- All tests pass via `cargo test -p lmlang-check`
</success_criteria>

<output>
After completion, create `.planning/phases/03-type-checking-graph-interpreter/03-02-SUMMARY.md`
</output>

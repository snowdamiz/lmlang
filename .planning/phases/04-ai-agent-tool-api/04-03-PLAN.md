---
phase: 04-ai-agent-tool-api
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - crates/lmlang-server/src/handlers/mod.rs
  - crates/lmlang-server/src/handlers/programs.rs
  - crates/lmlang-server/src/handlers/mutations.rs
  - crates/lmlang-server/src/handlers/queries.rs
  - crates/lmlang-server/src/handlers/verify.rs
  - crates/lmlang-server/src/handlers/simulate.rs
  - crates/lmlang-server/src/handlers/history.rs
  - crates/lmlang-server/src/router.rs
  - crates/lmlang-server/src/main.rs
  - crates/lmlang-server/src/lib.rs
autonomous: true
requirements:
  - TOOL-01
  - TOOL-02
  - TOOL-03
  - TOOL-04
  - TOOL-05
  - TOOL-06
  - STORE-03

must_haves:
  truths:
    - "POST /programs/{id}/mutations accepts ProposeEditRequest and returns ProposeEditResponse with validation feedback"
    - "GET /programs/{id}/overview returns program structure including modules, functions, node/edge counts"
    - "GET /programs/{id}/nodes/{node_id} returns node detail at requested verbosity level"
    - "GET /programs/{id}/functions/{func_id} returns function with its nodes and edges"
    - "POST /programs/{id}/neighborhood returns N-hop neighborhood of a node"
    - "POST /programs/{id}/search returns filtered nodes"
    - "POST /programs/{id}/verify runs type checking and returns structured diagnostics"
    - "POST /programs/{id}/simulate runs interpreter and returns output + trace"
    - "POST /programs/{id}/undo reverts last committed mutation"
    - "POST /programs/{id}/redo re-applies last undone mutation"
    - "POST /programs/{id}/checkpoints creates a named checkpoint"
    - "POST /programs/{id}/checkpoints/{name}/restore restores graph to checkpoint state"
    - "GET /programs/{id}/history lists past mutations"
    - "All error responses use structured diagnostic format with error codes"
    - "Server starts on configurable port and accepts HTTP requests"
  artifacts:
    - path: "crates/lmlang-server/src/handlers/mutations.rs"
      provides: "propose_edit handler"
      exports: ["propose_edit"]
    - path: "crates/lmlang-server/src/handlers/queries.rs"
      provides: "program_overview, get_node, get_function, neighborhood, search handlers"
      exports: ["program_overview", "get_node", "get_function", "neighborhood", "search"]
    - path: "crates/lmlang-server/src/handlers/verify.rs"
      provides: "verify handler"
      exports: ["verify"]
    - path: "crates/lmlang-server/src/handlers/simulate.rs"
      provides: "simulate handler"
      exports: ["simulate"]
    - path: "crates/lmlang-server/src/handlers/history.rs"
      provides: "undo, redo, create_checkpoint, restore_checkpoint, list_history, list_checkpoints, diff handlers"
      exports: ["undo", "redo", "create_checkpoint"]
    - path: "crates/lmlang-server/src/router.rs"
      provides: "build_router function assembling all routes"
      exports: ["build_router"]
    - path: "crates/lmlang-server/src/main.rs"
      provides: "Binary entrypoint starting axum server"
  key_links:
    - from: "crates/lmlang-server/src/handlers/mutations.rs"
      to: "crates/lmlang-server/src/service.rs"
      via: "state.service.lock().unwrap().propose_edit(request)"
      pattern: "service\\.lock.*propose_edit"
    - from: "crates/lmlang-server/src/handlers/verify.rs"
      to: "crates/lmlang-server/src/service.rs"
      via: "service.verify(scope, affected_nodes)"
      pattern: "service\\.lock.*verify"
    - from: "crates/lmlang-server/src/handlers/simulate.rs"
      to: "crates/lmlang-server/src/service.rs"
      via: "service.simulate(request)"
      pattern: "service\\.lock.*simulate"
    - from: "crates/lmlang-server/src/router.rs"
      to: "crates/lmlang-server/src/handlers/"
      via: "Router::new().route() with handler functions"
      pattern: "\\.route\\("
---

<objective>
Implement all HTTP handlers as thin wrappers around ProgramService, build the axum router wiring all endpoints, and create the binary entrypoint. This completes the HTTP surface for TOOL-01 through TOOL-06 and STORE-03.

Purpose: Makes the ProgramService accessible over HTTP/JSON so AI agents can interact with the graph system.
Output: Complete HTTP API with all endpoints functional, server binary that starts and accepts requests.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-agent-tool-api/04-CONTEXT.md
@.planning/phases/04-ai-agent-tool-api/04-RESEARCH.md
@.planning/phases/04-ai-agent-tool-api/04-01-SUMMARY.md
@.planning/phases/04-ai-agent-tool-api/04-02-SUMMARY.md
@crates/lmlang-server/src/service.rs
@crates/lmlang-server/src/state.rs
@crates/lmlang-server/src/schema/mod.rs
@crates/lmlang-server/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: HTTP handlers for mutations, verification, and program management</name>
  <files>
    crates/lmlang-server/src/handlers/mod.rs
    crates/lmlang-server/src/handlers/programs.rs
    crates/lmlang-server/src/handlers/mutations.rs
    crates/lmlang-server/src/handlers/verify.rs
  </files>
  <action>
    All handlers follow the thin-handler pattern from research: parse request with axum extractors, acquire service lock, call ProgramService method, return JSON response. Never hold the Mutex across async boundaries.

    1. Create `handlers/mod.rs` re-exporting sub-modules: programs, mutations, queries, verify, simulate, history.

    2. Create `handlers/programs.rs`:
       - `list_programs(State(state): State<AppState>) -> Result<Json<ProgramListResponse>, ApiError>`: lock service, call list_programs(), return.
       - `create_program(State(state): State<AppState>, Json(req): Json<CreateProgramRequest>) -> Result<Json<CreateProgramResponse>, ApiError>`: lock service, call create_program(name), return id+name.
       - `delete_program(State(state): State<AppState>, Path(id): Path<u64>) -> Result<Json<serde_json::Value>, ApiError>`: lock service, delete_program(ProgramId(id)), return { "success": true }.
       - `load_program(State(state): State<AppState>, Path(id): Path<u64>) -> Result<Json<serde_json::Value>, ApiError>`: lock service, load_program(ProgramId(id)), return { "success": true, "program_id": id }.

    3. Create `handlers/mutations.rs`:
       - `propose_edit(State(state): State<AppState>, Path(program_id): Path<u64>, Json(req): Json<ProposeEditRequest>) -> Result<Json<ProposeEditResponse>, ApiError>`:
         Lock service, verify program_id matches active program (or return error), call service.propose_edit(req), return response.
       - The handler is deliberately thin -- all batch/dry_run/validation logic lives in ProgramService.

    4. Create `handlers/verify.rs`:
       - **IMPORTANT**: Import `VerifyScope` and `VerifyResponse` from `crate::schema::verify`. Do NOT redefine these types here. They were defined in Plan 01 (schema/verify.rs) and are also used by ProgramService (Plan 02). All three layers (schema, service, handler) must use the same type definitions.
       - Define `VerifyRequest { scope: String, affected_nodes: Option<Vec<NodeId>> }` (Deserialize) as a handler-local request wrapper. scope is "local" or "full", parsed to VerifyScope.
       - `verify(State(state): State<AppState>, Path(program_id): Path<u64>, Json(req): Json<VerifyRequest>) -> Result<Json<VerifyResponse>, ApiError>`:
         Parse scope string to VerifyScope enum, lock service, call service.verify(scope, affected_nodes), return.
  </action>
  <verify>`cargo check -p lmlang-server` succeeds</verify>
  <done>Mutation, verification, and program management handlers implemented as thin wrappers around ProgramService. VerifyScope and VerifyResponse imported from schema::verify (not redefined).</done>
</task>

<task type="auto">
  <name>Task 2: HTTP handlers for queries, simulation, history, and router/main</name>
  <files>
    crates/lmlang-server/src/handlers/queries.rs
    crates/lmlang-server/src/handlers/simulate.rs
    crates/lmlang-server/src/handlers/history.rs
    crates/lmlang-server/src/router.rs
    crates/lmlang-server/src/main.rs
    crates/lmlang-server/src/lib.rs
  </files>
  <action>
    1. Create `handlers/queries.rs`:
       - `program_overview(State(state): State<AppState>, Path(program_id): Path<u64>) -> Result<Json<ProgramOverviewResponse>, ApiError>`: lock, call service.program_overview().
       - `get_node(State(state): State<AppState>, Path((program_id, node_id)): Path<(u64, u32)>, Query(params): Query<DetailQuery>) -> Result<Json<NodeView>, ApiError>`: parse detail from query params (default Standard), lock, call service.get_node(NodeId(node_id), detail).
       - `get_function(State(state): State<AppState>, Path((program_id, func_id)): Path<(u64, u32)>, Query(params): Query<DetailQuery>) -> Result<Json<GetFunctionResponse>, ApiError>`: lock, call service.get_function_context(FunctionId(func_id), detail).
       - `neighborhood(State(state): State<AppState>, Path(program_id): Path<u64>, Json(req): Json<NeighborhoodRequest>) -> Result<Json<NeighborhoodResponse>, ApiError>`: lock, call service.get_neighborhood(req.node_id, min(req.max_hops, 3), req.detail).
       - `search(State(state): State<AppState>, Path(program_id): Path<u64>, Json(req): Json<SearchRequest>) -> Result<Json<SearchResponse>, ApiError>`: lock, call service.search_nodes(req).
       - `DetailQuery { detail: Option<DetailLevel> }` (Deserialize) for query parameter extraction.

    2. Create `handlers/simulate.rs`:
       - `simulate(State(state): State<AppState>, Path(program_id): Path<u64>, Json(req): Json<SimulateRequest>) -> Result<Json<SimulateResponse>, ApiError>`: lock, call service.simulate(req).

    3. Create `handlers/history.rs`:
       - `list_history(State, Path(program_id)) -> Result<Json<ListHistoryResponse>, ApiError>`: lock, service.list_history().
       - `undo(State, Path(program_id)) -> Result<Json<UndoResponse>, ApiError>`: lock, service.undo().
       - `redo(State, Path(program_id)) -> Result<Json<RedoResponse>, ApiError>`: lock, service.redo().
       - `create_checkpoint(State, Path(program_id), Json(req)) -> Result<Json<CreateCheckpointResponse>, ApiError>`: lock, service.create_checkpoint(&req.name, req.description.as_deref()).
       - `list_checkpoints(State, Path(program_id)) -> Result<Json<ListCheckpointsResponse>, ApiError>`: lock, service.list_checkpoints().
       - `restore_checkpoint(State, Path((program_id, name)): Path<(u64, String)>) -> Result<Json<RestoreCheckpointResponse>, ApiError>`: lock, service.restore_checkpoint(&name).
       - `diff_versions(State, Path(program_id), Json(req): Json<DiffRequest>) -> Result<Json<DiffResponse>, ApiError>`: lock, service.diff_versions(req).

    4. Create `router.rs` with `build_router(state: AppState) -> Router`:
       Use axum 0.8 `/{param}` path syntax (NOT `/:param`).
       ```rust
       Router::new()
           // Program management
           .route("/programs", get(handlers::programs::list_programs))
           .route("/programs", post(handlers::programs::create_program))
           .route("/programs/{id}", axum::routing::delete(handlers::programs::delete_program))
           .route("/programs/{id}/load", post(handlers::programs::load_program))
           // Mutations (TOOL-01)
           .route("/programs/{id}/mutations", post(handlers::mutations::propose_edit))
           // Queries (TOOL-02)
           .route("/programs/{id}/overview", get(handlers::queries::program_overview))
           .route("/programs/{id}/nodes/{node_id}", get(handlers::queries::get_node))
           .route("/programs/{id}/functions/{func_id}", get(handlers::queries::get_function))
           .route("/programs/{id}/neighborhood", post(handlers::queries::neighborhood))
           .route("/programs/{id}/search", post(handlers::queries::search))
           // Verify (TOOL-03)
           .route("/programs/{id}/verify", post(handlers::verify::verify))
           // Simulate (TOOL-04)
           .route("/programs/{id}/simulate", post(handlers::simulate::simulate))
           // History (STORE-03)
           .route("/programs/{id}/history", get(handlers::history::list_history))
           .route("/programs/{id}/undo", post(handlers::history::undo))
           .route("/programs/{id}/redo", post(handlers::history::redo))
           .route("/programs/{id}/checkpoints", post(handlers::history::create_checkpoint))
           .route("/programs/{id}/checkpoints", get(handlers::history::list_checkpoints))
           .route("/programs/{id}/checkpoints/{name}/restore", post(handlers::history::restore_checkpoint))
           .route("/programs/{id}/diff", post(handlers::history::diff_versions))
           .layer(TraceLayer::new_for_http())
           .layer(CorsLayer::permissive())
           .with_state(state)
       ```

    5. Create `main.rs`:
       ```rust
       use lmlang_server::{router::build_router, state::AppState};
       use tracing_subscriber;

       #[tokio::main]
       async fn main() {
           tracing_subscriber::init();

           let db_path = std::env::var("LMLANG_DB_PATH")
               .unwrap_or_else(|_| "lmlang.db".to_string());
           let port = std::env::var("LMLANG_PORT")
               .unwrap_or_else(|_| "3000".to_string());

           let state = AppState::new(&db_path)
               .expect("Failed to initialize application state");

           let app = build_router(state);

           let addr = format!("0.0.0.0:{}", port);
           tracing::info!("lmlang server starting on {}", addr);

           let listener = tokio::net::TcpListener::bind(&addr).await.unwrap();
           axum::serve(listener, app).await.unwrap();
       }
       ```

    6. Update lib.rs to include: `pub mod handlers; pub mod router;`.

    7. Verify: `cargo build -p lmlang-server` (full build, not just check, since main.rs is a binary).
  </action>
  <verify>`cargo build -p lmlang-server` succeeds; all routes compile; `cargo check -p lmlang-server` has no warnings about unused imports</verify>
  <done>All HTTP handlers implemented (programs, mutations, queries, verify, simulate, history), router wires all endpoints with axum 0.8 path syntax, main.rs starts server on configurable port</done>
</task>

</tasks>

<verification>
- `cargo build -p lmlang-server` -- full binary builds successfully
- Count routes in router.rs: should be 17 routes covering all 7 requirements
- Each handler acquires lock, calls ProgramService, releases lock before response
- No `.await` while holding Mutex (grep for potential issues)
- All path parameters use `/{param}` syntax (axum 0.8, not `/:param`)
- Error responses return structured JSON via ApiError::IntoResponse
- CORS and tracing middleware layers present on router
- handlers/verify.rs imports VerifyScope and VerifyResponse from schema::verify (not redefining)
</verification>

<success_criteria>
- Server binary compiles and can start (verified by `cargo build`)
- All 17 routes wired covering: CRUD, mutations, queries, verify, simulate, undo/redo, checkpoints
- Handlers are thin -- no business logic, just extract->lock->call->respond
- axum 0.8 path syntax used throughout
- CORS permissive layer enabled (agents may call from various origins)
- TraceLayer for request logging
- main.rs reads LMLANG_DB_PATH and LMLANG_PORT from environment with sensible defaults
- VerifyScope/VerifyResponse used consistently from schema::verify across all layers
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-agent-tool-api/04-03-SUMMARY.md`
</output>

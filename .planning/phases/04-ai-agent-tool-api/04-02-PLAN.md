---
phase: 04-ai-agent-tool-api
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - crates/lmlang-storage/src/schema.rs
  - crates/lmlang-storage/src/migrations/002_edit_history.sql
  - crates/lmlang-server/src/undo.rs
  - crates/lmlang-server/src/service.rs
  - crates/lmlang-server/src/state.rs
  - crates/lmlang-server/src/lib.rs
autonomous: true
requirements:
  - STORE-03
  - TOOL-01
  - TOOL-02
  - TOOL-03
  - TOOL-04

must_haves:
  truths:
    - "ProgramService can apply single mutations with dry_run=true returning validation results without committing"
    - "ProgramService can apply batch mutations atomically (all-or-nothing) via clone-and-swap"
    - "Every committed mutation is recorded in the edit log with a UUID and timestamp"
    - "Agent can undo the last committed mutation and the graph reverts to its previous state"
    - "Agent can create named checkpoints that snapshot the full graph state"
    - "Agent can restore a named checkpoint, reverting the graph to that snapshot"
    - "Agent can list past mutations and view checkpoint metadata"
    - "ProgramService can run type verification in local or full scope"
    - "ProgramService can run the interpreter with provided inputs and return results"
    - "ProgramService can query nodes by ID, function boundary, N-hop neighborhood, and search/filter"
    - "Edit history persists in SQLite across sessions"
  artifacts:
    - path: "crates/lmlang-storage/src/migrations/002_edit_history.sql"
      provides: "edit_log and checkpoints SQLite tables"
      contains: "CREATE TABLE"
    - path: "crates/lmlang-server/src/undo.rs"
      provides: "EditCommand enum, EditLog, CheckpointManager"
      exports: ["EditCommand", "EditLog"]
    - path: "crates/lmlang-server/src/service.rs"
      provides: "ProgramService with mutation, query, verify, simulate, undo methods"
      exports: ["ProgramService"]
    - path: "crates/lmlang-server/src/state.rs"
      provides: "AppState with Arc<Mutex<ProgramService>>"
      exports: ["AppState"]
  key_links:
    - from: "crates/lmlang-server/src/service.rs"
      to: "crates/lmlang-core/src/graph.rs"
      via: "ProgramGraph mutation methods"
      pattern: "self\\.graph\\."
    - from: "crates/lmlang-server/src/service.rs"
      to: "crates/lmlang-check/src/typecheck/mod.rs"
      via: "validate_data_edge, validate_graph calls"
      pattern: "validate_(data_edge|graph)"
    - from: "crates/lmlang-server/src/service.rs"
      to: "crates/lmlang-check/src/interpreter/"
      via: "Interpreter::new, start, run"
      pattern: "Interpreter::new"
    - from: "crates/lmlang-server/src/undo.rs"
      to: "crates/lmlang-storage/src/migrations/002_edit_history.sql"
      via: "rusqlite queries against edit_log/checkpoints tables"
      pattern: "edit_log|checkpoints"
    - from: "crates/lmlang-server/src/service.rs"
      to: "crates/lmlang-server/src/undo.rs"
      via: "EditLog::record and EditLog::undo"
      pattern: "self\\.edit_log\\."
---

<objective>
Build the ProgramService application layer and undo system. ProgramService is the single coordinator that sits between HTTP handlers and the graph/storage/checker/interpreter crates. The undo system records all mutations in a SQLite-backed edit log and supports named checkpoints.

Purpose: This is the business logic layer that makes everything work. Handlers will be thin wrappers around ProgramService methods.
Output: Working ProgramService with mutation (single + batch + dry_run), query, verify, simulate, and undo/redo/checkpoint operations. All backed by persistent SQLite edit history.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ai-agent-tool-api/04-CONTEXT.md
@.planning/phases/04-ai-agent-tool-api/04-RESEARCH.md
@.planning/phases/04-ai-agent-tool-api/04-01-SUMMARY.md
@crates/lmlang-core/src/graph.rs
@crates/lmlang-check/src/typecheck/mod.rs
@crates/lmlang-check/src/interpreter/mod.rs
@crates/lmlang-storage/src/traits.rs
@crates/lmlang-storage/src/schema.rs
@crates/lmlang-storage/src/sqlite.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQLite migration for edit history and undo system implementation</name>
  <files>
    crates/lmlang-storage/src/migrations/002_edit_history.sql
    crates/lmlang-storage/src/schema.rs
    crates/lmlang-server/src/undo.rs
    crates/lmlang-server/src/lib.rs
  </files>
  <action>
    1. Create `crates/lmlang-storage/src/migrations/002_edit_history.sql`:
       ```sql
       CREATE TABLE IF NOT EXISTS edit_log (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           program_id INTEGER NOT NULL REFERENCES programs(id),
           edit_id TEXT NOT NULL,
           timestamp TEXT NOT NULL,
           description TEXT,
           command_json TEXT NOT NULL,
           undone INTEGER NOT NULL DEFAULT 0,
           UNIQUE(program_id, edit_id)
       );

       CREATE INDEX idx_edit_log_program ON edit_log(program_id, id);

       CREATE TABLE IF NOT EXISTS checkpoints (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           program_id INTEGER NOT NULL REFERENCES programs(id),
           name TEXT NOT NULL,
           timestamp TEXT NOT NULL,
           description TEXT,
           graph_json TEXT NOT NULL,
           edit_log_position INTEGER NOT NULL,
           UNIQUE(program_id, name)
       );
       ```

    2. Update `crates/lmlang-storage/src/schema.rs`: add the new migration to the migrations() function as `M::up(include_str!("migrations/002_edit_history.sql"))`.

    3. Create `crates/lmlang-server/src/undo.rs` with:

       - `EditCommand` enum (Serialize, Deserialize) with variants matching ProgramGraph mutations:
         - InsertNode { node_id: NodeId, op: ComputeNodeOp, owner: FunctionId }
         - RemoveNode { node_id: NodeId, removed_node: ComputeNode }
         - ModifyNode { node_id: NodeId, old_op: ComputeNodeOp, new_op: ComputeNodeOp, owner: FunctionId }
         - InsertDataEdge { edge_id: EdgeId, from: NodeId, to: NodeId, source_port: u16, target_port: u16, value_type: TypeId }
         - InsertControlEdge { edge_id: EdgeId, from: NodeId, to: NodeId, branch_index: Option<u16> }
         - RemoveEdge { edge_id: EdgeId, from: NodeId, to: NodeId, removed_edge: FlowEdge }
         - AddFunction { func_id: FunctionId, name: String, module: ModuleId, params: Vec<(String, TypeId)>, return_type: TypeId, visibility: Visibility }
         - AddModule { module_id: ModuleId, name: String, parent: ModuleId, visibility: Visibility }
         - Batch { commands: Vec<EditCommand>, description: String }

       - `EditCommand::inverse(&self) -> EditCommand` method: InsertNode -> RemoveNode, RemoveNode -> InsertNode, etc. For Batch, reverse the vec and invert each command (LIFO order per pitfall 2 from research).

       - `EditLog` struct holding a `rusqlite::Connection` reference (or taking connection as parameter for each method). Methods:
         - `record(conn: &Connection, program_id: ProgramId, command: &EditCommand, description: Option<&str>) -> Result<String, ApiError>` -- inserts into edit_log, returns UUID.
         - `undo(conn: &Connection, program_id: ProgramId) -> Result<Option<EditCommand>, ApiError>` -- finds last non-undone entry, marks it undone=1, returns the inverse command to apply.
         - `redo(conn: &Connection, program_id: ProgramId) -> Result<Option<EditCommand>, ApiError>` -- finds first undone entry, marks it undone=0, returns the command to re-apply.
         - `list(conn: &Connection, program_id: ProgramId) -> Result<Vec<HistoryEntry>, ApiError>` -- returns all entries ordered by id DESC.
         - `clear_redo_stack(conn: &Connection, program_id: ProgramId) -> Result<(), ApiError>` -- deletes all undone entries (new mutation invalidates redo stack).

       - `CheckpointManager` with methods:
         - `create(conn: &Connection, program_id: ProgramId, name: &str, description: Option<&str>, graph: &ProgramGraph) -> Result<(), ApiError>` -- serializes graph to JSON, records current edit_log position.
         - `restore(conn: &Connection, program_id: ProgramId, name: &str) -> Result<ProgramGraph, ApiError>` -- loads graph JSON, deserializes to ProgramGraph.
         - `list(conn: &Connection, program_id: ProgramId) -> Result<Vec<CheckpointView>, ApiError>`.
         - `delete(conn: &Connection, program_id: ProgramId, name: &str) -> Result<(), ApiError>`.

    4. Add `pub mod undo;` to lib.rs.

    5. Verify: `cargo check -p lmlang-server && cargo check -p lmlang-storage`.
  </action>
  <verify>`cargo check -p lmlang-server` succeeds; `cargo check -p lmlang-storage` succeeds (migration compiles)</verify>
  <done>edit_log and checkpoints tables defined in migration, EditCommand with inverse operations, EditLog with record/undo/redo/list, CheckpointManager with create/restore/list</done>
</task>

<task type="auto">
  <name>Task 2: ProgramService implementation with AppState</name>
  <files>
    crates/lmlang-server/src/service.rs
    crates/lmlang-server/src/state.rs
    crates/lmlang-server/src/lib.rs
  </files>
  <action>
    1. Create `crates/lmlang-server/src/state.rs`:
       - `AppState { service: Arc<Mutex<ProgramService>> }` with `#[derive(Clone)]`.
       - Constructor: `AppState::new(db_path: &str) -> Result<Self, ApiError>` that opens SQLite, creates ProgramService, wraps in Arc<Mutex>.

    2. Create `crates/lmlang-server/src/service.rs` with `ProgramService`:

       Fields: `graph: ProgramGraph`, `store: SqliteStore`, `program_id: ProgramId`, `conn: Connection` (for edit_log/checkpoint queries).

       **Program management methods:**
       - `new(conn: Connection) -> Result<Self, ApiError>` -- creates or loads default program.
       - `create_program(name: &str) -> Result<ProgramId, ApiError>` -- creates program in store.
       - `load_program(id: ProgramId) -> Result<(), ApiError>` -- loads from store, sets as active.
       - `list_programs() -> Result<Vec<ProgramSummary>, ApiError>`.
       - `delete_program(id: ProgramId) -> Result<(), ApiError>`.

       **Mutation methods (TOOL-01):**
       - `propose_edit(request: ProposeEditRequest) -> Result<ProposeEditResponse, ApiError>`:
         - If dry_run=true: clone graph, apply mutations to clone, run validation, return results. Discard clone.
         - If dry_run=false AND batch (>1 mutation): clone graph, apply all mutations to clone, validate. If all pass, swap clone into self.graph, record batch EditCommand, save to store. If any fail, return errors, discard clone. (Clone-and-swap per research pitfall 1.)
         - If dry_run=false AND single mutation: apply to real graph, validate, if fails revert via inverse command, return error. If succeeds, record EditCommand, save to store.
         - Clear redo stack on any successful commit.
         - Return created entities (node IDs, edge IDs, etc.) in order.

       - `apply_mutation(graph: &mut ProgramGraph, mutation: &Mutation) -> Result<(CreatedEntity option, EditCommand), ApiError>`: applies a single Mutation to the given graph, returns created entity and the EditCommand for undo recording. Maps Mutation variants to ProgramGraph methods:
         - InsertNode -> graph.add_compute_node(op, owner) -> returns NodeId
         - RemoveNode -> graph.remove_compute_node(id) -> captures removed node for undo
         - ModifyNode -> graph.get_compute_node(id) to get old op, then remove+re-add with new op (ProgramGraph has no update_node -- do remove_compute_node then add_compute_node? OR modify in-place if possible. Check if there's a way. If not, the service should have a helper that swaps the op in the compute StableGraph. NOTE: ProgramGraph graphs are private -- mutations go through methods. The simplest approach: since there's no modify method, treat ModifyNode as RemoveNode+InsertNode, but preserve the NodeId. Actually StableGraph allows direct node weight mutation. But ProgramGraph's compute graph is private. This is a gap. For now: store the old ComputeNode, call remove_compute_node (which also removes edges), then add_compute_node with new op. PROBLEM: this changes NodeId and removes edges. Better approach: add a `modify_compute_node_op` method to ProgramGraph in lmlang-core that takes NodeId and new ComputeNodeOp. It should access `self.compute[idx].op = new_op` directly. Add this method to ProgramGraph.)
         - AddEdge -> graph.add_data_edge(...)
         - AddControlEdge -> graph.add_control_edge(...)
         - RemoveEdge -> graph.remove_edge(id) -> captures removed edge for undo
         - AddFunction -> graph.add_function(...)
         - AddModule -> graph.add_module(...)

       **IMPORTANT**: Add `modify_compute_node_op(&mut self, id: NodeId, new_op: ComputeNodeOp) -> Result<ComputeNodeOp, CoreError>` to ProgramGraph in `crates/lmlang-core/src/graph.rs`. This mutates the op in-place and returns the old op. Implementation: `let idx = id.into(); let node = self.compute.node_weight_mut(idx).ok_or(CoreError::NodeNotFound { id })?; let old = std::mem::replace(&mut node.op, new_op); Ok(old)`.

       **Validation method (TOOL-03):**
       - `verify(scope: VerifyScope, affected_nodes: Option<Vec<NodeId>>) -> Result<VerifyResponse, ApiError>`:
         - VerifyScope::Local: if affected_nodes provided, call validate_data_edge for each edge touching those nodes. Collect errors and warnings.
         - VerifyScope::Full: call validate_graph(&self.graph). Convert TypeError vec to DiagnosticError vec.
         - Return { valid: bool, errors: Vec<DiagnosticError>, warnings: Vec<DiagnosticWarning> }.

       **Query methods (TOOL-02):**
       - `get_node(node_id: NodeId, detail: DetailLevel) -> Result<NodeView, ApiError>`: look up in graph, build NodeView per detail level.
       - `get_function_context(func_id: FunctionId, detail: DetailLevel) -> Result<GetFunctionResponse, ApiError>`: get function def, all owned nodes, all edges between those nodes.
       - `get_neighborhood(node_id: NodeId, max_hops: u32, detail: DetailLevel) -> Result<NeighborhoodResponse, ApiError>`: BFS from node_id up to max_hops (capped at 3), collect visited nodes and edges. Use petgraph BFS via the compute graph reference.
       - `search_nodes(filter: SearchRequest) -> Result<SearchResponse, ApiError>`: filter nodes by op type string, owner function, value_type on edges. Iterate graph.compute().node_indices(), apply filters, build NodeViews.
       - `program_overview() -> Result<ProgramOverviewResponse, ApiError>`: module tree, function list, counts.

       **Detail level rendering helper:**
       - `render_node(node_id: NodeId, node: &ComputeNode, detail: DetailLevel) -> NodeView`:
         - Summary: id + op name string only
         - Standard: + owner, incoming/outgoing edges
         - Full: + complete op_data as serde_json::Value, full port info

       **Simulate method (TOOL-04):**
       - `simulate(request: SimulateRequest) -> Result<SimulateResponse, ApiError>`:
         - Convert serde_json::Value inputs to interpreter Value (match on JSON type: number->I32/I64/F64 based on context, bool->Bool, null->Unit, etc. Best effort conversion; function signature can help disambiguate).
         - Create Interpreter with config, start(function_id, inputs), run().
         - Match on ExecutionState: Completed -> serialize result, Error -> serialize error + partial results.
         - If trace_enabled, collect trace entries.
         - Collect io_log.

       **Undo methods (STORE-03):**
       - `undo() -> Result<UndoResponse, ApiError>`: call EditLog::undo to get inverse command, apply_edit_command to graph, save to store.
       - `redo() -> Result<RedoResponse, ApiError>`: call EditLog::redo to get command, apply_edit_command to graph, save to store.
       - `create_checkpoint(name: &str, description: Option<&str>) -> Result<CreateCheckpointResponse, ApiError>`: delegate to CheckpointManager::create.
       - `restore_checkpoint(name: &str) -> Result<RestoreCheckpointResponse, ApiError>`: delegate to CheckpointManager::restore, replace self.graph.
       - `list_checkpoints() -> Result<ListCheckpointsResponse, ApiError>`.
       - `list_history() -> Result<ListHistoryResponse, ApiError>`.
       - `diff_versions(request: DiffRequest) -> Result<DiffResponse, ApiError>`: load two graph versions (from checkpoints or current), compare node/edge sets, return added/removed/modified.

       - Helper `apply_edit_command(graph: &mut ProgramGraph, cmd: &EditCommand) -> Result<(), ApiError>`: applies an EditCommand (used for undo/redo replay). Maps each EditCommand variant to ProgramGraph mutations.

    3. Add `pub mod service; pub mod state;` to lib.rs.

    4. Also add `modify_compute_node_op` to `crates/lmlang-core/src/graph.rs` as described above.

    5. Add `crates/lmlang-core/src/graph.rs` to files_modified in your tracking (this is a small addition of one method).

    6. Verify: `cargo check -p lmlang-server && cargo test -p lmlang-core`.
  </action>
  <verify>`cargo check -p lmlang-server` succeeds; `cargo test -p lmlang-core` passes (new method doesn't break existing tests); `cargo test -p lmlang-check` passes</verify>
  <done>ProgramService implements all 5 capabilities (mutate, query, verify, simulate, undo) with proper edit log recording, clone-and-swap batch atomicity, and checkpoint management. AppState wraps in Arc<Mutex>. ProgramGraph gains modify_compute_node_op method.</done>
</task>

</tasks>

<verification>
- `cargo check -p lmlang-server` -- all service and undo code compiles
- `cargo test -p lmlang-core` -- existing tests + new modify_compute_node_op doesn't break anything
- `cargo test -p lmlang-check` -- existing tests unaffected
- `cargo test -p lmlang-storage` -- migration applies cleanly
- grep for `edit_log` in undo.rs confirms SQLite integration
- grep for `propose_edit` in service.rs confirms mutation workflow
- grep for `clone()` in service.rs confirms clone-and-swap pattern for batch
</verification>

<success_criteria>
- ProgramService.propose_edit handles single, batch, and dry_run modes per locked decisions
- Batch mutations use clone-and-swap (all-or-nothing) per locked decision
- Every committed mutation recorded in edit_log with UUID and timestamp
- Undo reverses last mutation, redo re-applies, both update graph and store
- Named checkpoints create full graph snapshots in SQLite
- Checkpoint restore replaces current graph state
- History is inspectable (list mutations, list checkpoints)
- Verify supports local (affected nodes only) and full (entire graph) scopes
- Simulate runs interpreter and returns results/trace/io_log
- Query methods support all detail levels (summary/standard/full)
- N-hop neighborhood capped at 3 hops
- All operations persist to SQLite
</success_criteria>

<output>
After completion, create `.planning/phases/04-ai-agent-tool-api/04-02-SUMMARY.md`
</output>
